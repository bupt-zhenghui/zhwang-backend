# 面试知识准备



## 通用问答

这是一些在国企的结构化面试、互联网的hr面中经常出现的问题。这些问题主要考察人际沟通能力，对面试结果的影响一般较小，但是注意别犯太大失误。列出的一些问题，不需要很认真的去背，事先有准备即可。此类问题的建议准备时间：【3分钟/题】

- 你有什么缺点/优点

- 为什么报考本单位，对岗位有什么了解

- 你在大学期间遇到的最有挑战的事是什么？如何解决的

- 如何面对压力，最近有没有让你感到愤怒的事情

- 对自己的未来规划是怎样的

- 职业规划

- 对部门和岗位有什么了解（提前了解公司和部门）
  
  
  
  - 要根据产品需求和设计方案，选择合适的测试环境，执行测试用例，进行缺陷定位和恢复，提交测试报告。
  
  - 项目测试环境搭建以及自动化测试软件的开发和维护。
  
  - 优化测试流程，站在用户的角度提出系统优化建议，完善用户体验。
  
  - **技术背景**：掌握python，熟悉数据结构，计算机网络，mysql, linux开发，以及git 常用指令
  
  - 内驱力强，良好的沟通能力和团队协作能力，做事细心认真，负责。
  
    
  
- 有什么问题：岗位的培养机制/具体业务/工作氛围/发展路径。预计什么时候可以收到面试结果。

- **博弈论的应用场景**
  
  
  
  - 场景1：拍卖
  
  - 场景2：人机围棋博弈
  - 场景3：经济市场的竞争
  - 场景4：网络入侵与网络监测



## 机器学习/深度学习

- 过拟合与欠拟合

    过拟合（Overfitting）和欠拟合（Underfitting）是机器学习中两个重要的概念，它们都涉及到模型在训练数据上的表现。

    1. **过拟合（Overfitting）**：

        - 过拟合指的是模型在训练数据上表现得太好，以至于学习到了训练数据中的噪声和随机变化，导致在未见过的测试数据上表现较差。

        - 过拟合通常是因为模型过于复杂，参数过多，以至于可以完美地拟合训练数据，但是泛化到未见过的数据时效果变差。

        - 具体表现为模型在训练数据上的误差很低，但在测试数据上的误差却很高。

            

    2. **欠拟合（Underfitting）**：

        - 欠拟合指的是模型未能在训练数据上学到足够的特征或模式，导致无法很好地拟合数据，表现较差。

        - 欠拟合通常是因为模型过于简单，或者没有充分训练，以至于不能捕捉到数据中的复杂关系。

        - 具体表现为模型在训练数据和测试数据上的误差都比较高。

            

    解决过拟合和欠拟合的方法如下：

    - **过拟合的解决方法**：

        - 增加训练数据，以提供更多的样本给模型学习。

        - 减少模型的复杂度，比如减少参数数量，使用正则化方法来限制参数的大小。

        - 使用交叉验证来评估模型的泛化性能，及时检测并处理过拟合。

        - 使用集成学习方法，比如随机森林、梯度提升树等，来减少过拟合的风险。

            

    - **欠拟合的解决方法**：

        - 增加模型的复杂度，比如增加参数数量，增加神经网络的层数或节点数。

        - 提取更多的特征，以便模型可以学到更多数据中的模式。

        - 增加训练时间，以便模型有更多机会学习数据中的特征。

        - 使用更复杂的模型，比如深度神经网络等，以提高模型的表达能力。

            

    在实际应用中，通过调整模型的复杂度、正则化参数、增加训练数据等方法，可以有效地解决过拟合和欠拟合问题，从而提高模型的泛化能力和性能。

- **机器学习与深度学习的区别**

    |                | 机器学习                                           | 深度学习                                             |
    | -------------- | -------------------------------------------------- | ---------------------------------------------------- |
    | 概念           | 是一种人工智能方法                                 | 是机器学习的一个分支                                 |
    | 适合处理的任务 | 数据集是**结构化**的，具有定义明确的**标签**的任务 | 理解**非结构化数据**，如语音，图像，文字等           |
    | 训练数据集     | **手动进行选择和提取特征**，然后才能训练           | 使用多层神经网络和**反馈**机制，**自动学习特征**     |
    | 常见算法       | 支持向量机，线性回归，决策树等                     | **多层神经网络模型**：如卷积神经网络，循环神经网络等 |
    | 计算资源       | 消耗相对较低                                       | 需要大量的计算资源                                   |

## python语法

1. **`is`** 和 `==` 有什么区别?

   + `is` 语句是**引用相等**：即两个对象是否指向同一个内存地址

   + `==` 用于检查**值是否相等**。

     ```python
     a = [1, 2, 3]
     b = a
     c = [1, 2, 3]
     # a 和 b 指向的是同一块内存地址 is: 对象相等
     print(a is b)   #True
     # == 值相等
     print(a == b)   #True
     #-------------------------------------------------------
     print(a is c)   #False:  a与c 只是值相等，但是不是指向同一个对象
     print(a == c)   #True: a 与 c 值相等
     ```

2. python**装饰器/装饰器函数**

   **装饰器函数用于修饰其他函数的行为**：装饰器函数接受**一个函数作为参数**，并返回一个修改后的函数。其提供了一种简洁的方式来修改函数的功能，而无需修改原函数的定义。提高了**代码的重用性和可维护性**

   + python中，提供了使用**@语法糖来应用装饰器**的方式，使代码更加简洁

   ```python
   def decorator_function(original_function):
       def wrapper_function():
           print("装饰器函数开始")
           original_function()
           print("装饰器函数截止")
       return wrapper_function
   # 注意装饰器函数要返回一个函数
   
   # def original_function():
   #     print("hello world")
   #
   # decorated_function = decorator_function(original_function)
   # decorated_function()
   
   # 或使用@语法糖
   @decorator_function
   def original_function():
       print("hello world")
   
   original_function()
   ```

   

3. 函数中参数是**值传递**还是**引用传递**

   **都为引用传递**：对于可变数据对象，会直接修改对象的值；对于不可变数据对象，重新绑定参数会创建一个新对象。

   ```python
   a = [1, 2, 3]
   num = 5
   
   # 对于可变数据类型，即使 change 函数无返回值，列表 a 的值也已经改变，说明是引用传递（地址）
   def change(a):
       a.append(4)
   change(a)  #结果为[1,2,3,4]
   
   # 对于不可变数据类型，如果没有返回语句的话，这时候 num的值是没有改变的。
   def change1(num):
       num = num + 1
   #     整数是不可变对象，重新绑定参数会创建一个新对象
   change1(num)   #结果仍为5
   
   ```

   

4. main()方法中 **args 参数**有什么作用：用于处理**命令行参数**：可以用于配置程序，传递输入数据等。

5. arraylist 和 linklist的区别

6. 了解那些数据结构

7. **多线程/线程**

8. 协程

9. **深拷贝，浅拷贝与引用拷贝**

   ```python
   import copy
   a = [1,2,3,[4]]
   
   b = a #直接赋值操作：a与b指向同一个对象: a怎么变，b的值就会怎么变
   c = a.copy()  #浅拷贝：只拷贝父对象，不拷贝子对象（可变数据类型）：父对象中有指针指向子对象，这个没有拷贝。因此，a怎么变，父对象的值不变，但是父对象的子对象依然会改变
   d = copy.deepcopy(a)  #深拷贝：完全拷贝父对象和子对象，两者完全独立的，原对象怎么变化都不会影响新对象
   
   
   a.append(6)
   print(b)  #[1,2,3,[4],6]
   print(c)  #[1,2,3,[4]]
   print(d)  #[1,2,3,[4]]
   
   a[3].append(5)
   print(b)  #[1,2,3,[4,5],6]
   print(c)  #[1,2,3,[4,5]]
   print(d)  #[1,2,3,[4]]
   
   a.append("hello")
   print(b)  #[1,2,3,[4,5],6,"hello"]
   print(c)  #[1,2,3,[4,5]]
   print(d)  #[1,2,3,[4]]
   
   ```

   

10. python一共有哪些**数据类型**：【注意】：**字符串，列表，字典，元组，集合都属于可迭代类型**。

    ​																**元组(tuple)**：**不可变的有序序列，可以包含不同类型的元素**

    + **不可变类型**：数字（整型:只有`int` / 浮点型：只有`float` /  复数），字符串，元组(tuple)， 布尔类型
    + **可变类型**：列表/字典/集合





## 计算机专业知识

计算机专业知识一般在互联网企业面试中出现很多，在国企面试中偶尔会出现，但不会太多、太难

### 计算机网络



#### 网络的分层模型

1. 介绍下OSI七层模型，每一层大概是干什么的

    - 物理层：定义了在物理介质上传输比特流规范，协议：IEEE 802.2
    - 数据链路层：负责结点-结点的数据传输，在链路层以帧为单位进行传输、物理寻址
    - 网络层：路由和转发。负责源主机到目的主机的分组交付，确保数据送达目的主机
    - 传输层：分段与重组。为端系统上的进程提供逻辑通信机制，发送发将数据分段，接收方将数据重组
    - 会话层：不同机器上的用户之间建立及管理会话，协议：SSL、TLS
    - 表示层：信息的表示，如何解码信息
    - 应用层：各种应用程序协议，如：HTTP、FTP、SMTP、SSH

    <img src="https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403121932922.png" alt="img" style="zoom: 67%;" />

2. <font color=red>介绍下TCP/IP四层模型，每一层大概是干什么的</font>

    ![TCP/IP 四层模型](https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403121932748.png)

3. 为什么计算机网络需要分层

    - 复杂的系统需要分层，因为每一层都需要专注于一件事情。
    - 各层之间相互独立，不需要关心其他层是如何实现的，只需要解决需要解决的问题就可以
    - 提高了整体的灵活性，每一层都可以使用最适合的技术来实现（类似开发中的低耦合）
    - 大问题化小，分层可以将复杂的网络问题分解为许多比较小的子问题逐个解决



#### 应用层

1. 常见的应用层协议有哪些

2. HTTP是什么，HTTP与HTTPs的区别是什么

    - 端口号：HTTP默认80，HTTPS默认443
    - URL前缀：HTTP默认前缀为`http://`，HTTPS默认前缀为`https://`
    - 安全性和资源消耗：HTTP协议所有传输的内容都是**明文**，客户端和服务器无法验证对方身份；HTTPS所有传输的内容都**进行了加密(在TCP与HTTP层加入了安全协议)**，加密采用对称加密，对称加密使用的密钥采用非对称加密。HTTP安全性低，但HTTPS耗费了更多服务器资源。
    - HTTP建立连接时相对简单，TCP三次握手即可进行报文传输； HTTPS 在TCP三次握手的基础上，还需进行 SSL/TLS 的握手过程。

3. HTTPS 解决了HTTP什么问题：

    1. http明文传输带来的风险： 
        1. **窃听风险**：可以获取通信内容，用户号容易没 --------------> **信息加密**
        2. **篡改风险**：植入垃圾广告，视觉污染，用户眼容易瞎------------------->**校验机制**
        3. **冒充风险**：冒充淘宝网站，用户钱容易没--------------------->**身份证书**

4. HTTP的请求报文与响应报文有哪些参数【不需要全记得】

    | 请求头字段名    | 说明                         | 示例                                            |
    | --------------- | ---------------------------- | ----------------------------------------------- |
    | Accept          | 能够接受的回应内容类型       | Accept: text/plain                              |
    | Accept-Charset  | 能够接受的字符集             | Accept-Charset: uff-8                           |
    | Accept-Encoding | 能偶接受的编码方式列表       | Accept-encoding: gzip, deflate                  |
    | Cache-Control   | 指定在这次请求中所有缓存机制 | Cache-Control: no-cache                         |
    | Connection      | 浏览器想要优先使用的连接类型 | Connection: keep-alive                          |
    | Content-Length  | 请求体的长度（字节数）       | Content-Length: 348                             |
    | Content-Type    | 请求体的多媒体类型           | Content-Type: application/x-www-form-urlencoded |
    | Cookie          | cookie                       |                                                 |
    | Date            | 发送消息的日期时间           | Date: Tue, 15 Nov 1994 08:12:31 GMT             |
    | Host            | 服务器的域名及端口号         | Host: en.wikipedia.org:80                       |
    | User-Agent      | 浏览器的身份标识             |                                                 |

    | 响应头字段名   | 说明                         | 示例                                            |
    | -------------- | ---------------------------- | ----------------------------------------------- |
    | Connection     | 浏览器想要优先使用的连接类型 | Connection: keep-alive                          |
    | Date           | 发送消息的日期时间           | Date: Tue, 15 Nov 1994 08:12:31 GMT             |
    | Content-Type   | 请求体的多媒体类型           | Content-Type: application/x-www-form-urlencoded |
    | Content-Length | 请求体的长度（字节数）       | Content-Length: 348                             |

    

5. HTTP1.0与HTTP2.0的区别是什么【我自己还没背过】

6. HTTP协议的常见状态码

    |      |            类别            |        原因        |                             举例                             |
    | :--: | :------------------------: | :----------------: | :----------------------------------------------------------: |
    | 1XX  |  Informational（信息性）   |    请求正在处理    |                      1XX大概率不会碰到                       |
    | 2XX  |      Success（成功）       |      请求正常      |                            200 OK                            |
    | 3XX  |   Redirection（重定向）    |       重定向       |                     301 Move Permanently                     |
    | 4XX  | Client Error（客户端错误） | 服务器无法处理请求 | 400 Bad Request：请求参数不合法、请求方法错误<br />401 Unauthorized：未认证的请求<br />403 Forbidden：拒绝HTTP请求，针对非法请求<br />404 Not Found：请求资源未找到 |
    | 5XX  | Server Error（服务端错误） | 服务器处理请求出错 | 500 Internal Server Error：服务端bug<br />502 Bad Gateway：服务端返回错误响应 |

7. **get方法与post方法**

    1. get方法用于向服务器请求数据。请求的参数一般放在url中

    2. post方法是请服务器根据请求体(body)对请求的资源进行处理：如在**网页底部留言**

    3. get方法和post方法都是**安全且幂等**的吗

        1. 安全：不会破坏服务器的资源。

        2. 幂等：多次执行相同的操作，结果都是相同的。

        3. get请求是从服务器获取资源，无论做了多少次操作，服务器的数据都是安全的。因此get请求是安全和幂等的。

        4. post请求会修改服务器的资源，不安全且不幂等的。

            （虽然 POST 用 **body 传输数据**，而 GET **用 URL 传输**，这样数据会在浏览器地址拦容易看到，但是并不能说 GET 不如 POST 安全的。

            因为 HTTP 传输的内容都是**明文**的，虽然在浏览器地址拦看不到 POST 提交的 body 数据，但是只要抓个包就都能看到了。

            所以，要避免传输过程中数据被窃取，就要使用 HTTPS 协议，这样所有 HTTP 的数据都会被加密传输。）
            
            


7. **Cookie与session的区别**    详细区别见：https://www.cnblogs.com/ityouknow/p/10856177.html

![截屏2024-03-21 12.41.40](https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403211243830.png)

上方的图就是Leetcode网站上所使用到的cookie，其中的leetcode_session字段就是当前账号与服务器端进行交互的关键，通过这个id服务器可以确定你是哪个用户，从而避免了每次访问网站都需要登录。当cookie过期时你就需要重新登陆一次了（leetcode一般是一个月登陆一次，也就是这个cookie_session的有效期大概是30天）



Cookie和Session都是用来在Web应用程序中跟踪用户状态的机制，但它们有一些关键区别：

1. **存储位置**：
    - Cookie：存储在客户端（通常是用户的浏览器）上，以文本文件的形式存储在用户的计算机上。
    - Session：存储在服务器上，通常在内存中或者数据库中。
2. **内容**：
    - Cookie：包含有关用户的少量数据，通常是用户标识符、会话 ID 或其他与用户相关的信息。
    - Session：通常包含比 Cookie 更多的数据，因为它可以存储更大量的信息，例如用户的购物车内容、登录状态等。
3. **安全性**：
    - Cookie：由于存储在客户端，存在一定的安全风险，因为可以被篡改或者被其他人窃取。
    - Session：存储在服务器端，相对更安全，因为用户无法直接访问或修改会话数据。
4. **过期时间**：
    - Cookie：可以设置过期时间，可以是会话级别的（浏览器关闭时过期）或者持久性的（在设定的时间后过期）。
    - Session：通常在用户关闭浏览器或者一段时间后自动过期，也可以由服务器端的配置控制。
5. **处理方式**：
    - Cookie：需要在客户端的每个 HTTP 请求中发送到服务器端。
    - Session：服务器端通过会话 ID 来识别用户，通常是在 Cookie 中存储一个会话 ID，然后服务器根据这个 ID 来查找相应的会话数据。
    - 

**cookie, session 与 token 的区别**



+ session: 是一种服务器端的状态管理机制，用于跟踪和存储用户在Web应用程序中的状态信息。当用户访问应用程序时，服务器会为每个会话分配一个唯一的会话ID。这个会话ID通常通过"cookie"或URL参数在用户的浏览器和服务器之间进行传递。会话数据存储在服务器上，可以包含**用户的身份信息、权限、购物车内容**等。

+ cookie: "Cookie"是一种在用户浏览器和Web服务器之间传递数据的小型文本文件。服务器可以通过HTTP响应的"Set-Cookie"头将cookie发送到用户的浏览器，然后浏览器会在后续的请求中通过"Cookie"头将cookie值发送回服务器。Cookie常用于**存储持久化数据，比如用户的首选语言、登录状态**等。

+ token: “Token"是一种代表**用户身份和权限**的数据结构。它可以是一串加密的字符串，通常包含有关用户的信息，比如用户名、角色和过期时间。Token通常是无状态的，这意味着**服务器不需要在后端存储任何关于令牌本身的信息**。**令牌可以通过各种方式传递**，**如HTTP头部、URL参数或"cookie”**。

  **位置与存储：**

  - Session数据存储在服务器上，客户端只保留一个会话ID，通常通过"cookie"传递。
  - Cookie存储在客户端浏览器中，可以包含各种数据，但大小有限制。
  - Token也存储在客户端，通常是作为HTTP头部的一部分发送到服务器。

  

  **数据内容：**

  - Session通常包含敏感数据，因为它存储在服务器上。
  - Cookie可以包含持久性数据，如用户偏好设置。
  - Token通常包含用户的身份信息和权限声明。

  

  **状态与无状态：**

  - Session是有状态的，服务器需要存储会话数据。
  - Cookie和Token是无状态的，服务器不需要在后端存储相关数据。



#### 传输层

1. 传输层的作用是什么？与网络层有什么区别

    - 传输层协议为运行在不同主机（端系统）上的进程提供了一种逻辑通信机制，负责对消息的【分段与重组】

    - 发送方：将应用递交的消息分成一个或多个的Segment，并向下传给网络层

    - 接收方：将接收到的segment组装成消息并向上交给应用层
    - 与网络层的差异
        - 传输层：提供应用进程之间的逻辑通信机制（位于网络层之上，依赖 于网络层服务）（电脑分配信息到不同进程）
        - 网络层：提供主机之间的逻辑通信机制（从这个电脑发到那个电脑）
        - 举例：Ann家的12个孩子给Bill家的12个孩子写信，主机就是两个家庭，进程是孩子们，传递的消息是信封里的信，传输层协议是负责将信正确交给不同孩子的Ann和Bill，网络层协议是邮政系统

2. 如何唯一确定一个TCP连接：

    **源地址，源端口； 目的地址，目的端口四元组**

3. 如何在linux系统中查看TCP状态：`netstate -napt` 

4. 传输层的主要协议是哪两个

5. <font color=red>TCP与UDP的区别</font>

    |                  |    TCP     |    UDP     |
    | :--------------: | :--------: | :--------: |
    |   是否面向连接   |     是     |     否     |
    |     是否可靠     |     是     |     否     |
    |    是否有状态    |     是     |     否     |
    |     传输效率     |    较慢    |    较快    |
    |     传输形式     | **字节流** | 数据报文段 |
    |     首部开销     | 20-60bytes |   8bytes   |
    | 是否提供广播服务 |     否     |     是     |

6. TCP与UDP的主要使用场景

    1. TCP： HTTP/HTTPS/FTP

    2. UDP:   DNS/视频，音频等多媒体通信，广播通信

7. <font color=red>【非常重要】三次握手与四次挥手</font>

    ![img](https://pic3.zhimg.com/80/v2-b5489cf99930e9179c854f44a57c51f6_1440w.webp)

    ```shell
    # 三次握手
    第一次：客户端发送SYN数据包给服务端，客户端进入等待状态
    第二次：服务端接收到请求，向客户端发送ACK+SYN报文段，服务端进入等待状态
    第三次：客户端接收到服务端发来的请求，向服务端发送ACK报文段表示接收了请求，完成三次握手
    ```

    ```shell
    # 四次挥手
    第一次：客户端发送FIN报文段，关闭客户端到服务器的数据传送，进入等待状态
    第二次：服务器收到FIN报文段，向客户端发送ACK，表明收到消息（但此时服务端可能还有数据没有传输完，需要继续传输）
    第三次：服务端向客户端发送FIN报文段，请求关闭连接
    第四次：客户端收到报文段，发送ACK，服务器收到后直接终止连接。如果客户端等待2MSL后没有收到回复，证明服务端已正常关闭，随后客户端断开连接
    ```

8. 为什么需要三次握手，不是两次 or 四次？（三次握手保证双方具有正常的发送和接受能力）（注意：**握手丢失与为什么需要三次握手是不一样的概念**）

    1. 三次握手才可以**阻止重复历史连接【旧历史报文】的初始化（首要原因）**

        **服务器没有中间状态来阻止历史连接，导致服务器可能建立一个历史连接，造成资源浪费。**

        <img src="img/image-20240406191024406.png" alt="image-20240406191024406" style="zoom: 50%;" />

    2. 三次握手才可以**同步双方的初始序列号**

        TCP 协议的通信双方， 都必须维护一个「序列号」， **序列号**是可靠传输的一个关键因素，它的作用：

        - 接收方可以去除重复的数据；
        - 接收方可以根据数据包的序列号按序接收；
        - 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；

        可见，序列号在 TCP 连接中占据着非常重要的作用，所以当客户端发送携带「初始序列号」的 `SYN` 报文的时候，需要服务端回一个 `ACK` 应答报文，表示客户端的 SYN 报文已被服务端成功接收；

        当服务端发送「初始序列号」给客户端的时候，依然也要得到客户端的应答回应，**这样一来一回，才能确保双方的初始序列号能被可靠的同步。**四次握手其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」。

        **两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。**

    3. 三次握手才可以**避免资源浪费**

        如果只有「两次握手」，当客户端发生的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN` ，**由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端每收到一个 `SYN` 就只能先主动建立一个连接，建立多个冗余的无效链接，造成不必要的资源浪费**

        **总结：不使用「两次握手」和「四次握手」的原因：**

        - **「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；**

        - **「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数**

          

9. 为什么挥手需要四次

    挥手需要四次主要是因为**：在请求断开连接的一方提出解除握手以后，被请求的一方可能还有未传完的数据**。此时被请求一方会先发送ACK报文段，表示我方收到了你方请求（第二次握手），当被请求方完成数据传输后会发送FIN报文段表示请求关闭连接。

    

10. 什么情况下**只要三次挥手**就可以：

    当被动关闭方（上图的服务端）在 TCP 挥手过程中，「**没有数据要发送」并且「开启了 TCP 延迟确认机制」，那么第二和第三次挥手就会合并传输，这样就出现了三次挥手。**

    

11. close-wait与time-wait在什么阶段发生

     - 在TCP四次挥手的过程中出现

     - 被动关闭的一方在接收到FIN报文段后，回复ACK，并进入CLOSE_WAIT状态

     - 被动关闭的一方在完成所有数据发送后，向主动关闭方发送FIN，并进入LAST_ACK状态

     - 主动关闭方收到FIN并回复ACK，进入TIME_WAIT状态

     - 被动关闭方接收到ACK后进入CLOSED状态

     - 主动关闭方等待2MSL后，结束TIME_WAIT，进入CLOSED状态

       

12. 第四次挥手时客户端为什么要等待**2MSL（max segment lifetime:最大报文生存时间）**的时间

     - TIME_WAIT是为了解决**网络丢包和网络不稳定**等问题**

     - 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以**一来一回需要等待 2 倍的时间**。如果被动关闭方没有收到断开连接的最后的 ACK 报文，就会**触发超时重发** `FIN` 报文，另一方接收到 `FIN` 后，会重发 ACK 给被动关闭方， 一来一去正好 2 个 MSL。相当于**至少允许报文丢失一次**。

       

13. 什么是SYN攻击，如何避免SYN攻击？

     假设攻击者短时间伪造不同 IP 地址的 `SYN` 报文，服务端每接收到一个 `SYN` 报文，就进入`SYN_RCVD` 状态，但服务端发送出去的 `ACK + SYN` 报文，无法得     到未知 IP 主机的 `ACK` 应答，久而久之就会**占满服务端的半连接队列**，使得服务端不能为正常用户服务。避免 SYN 攻击方式，可以有以下四种方法：
    
    + 调大 netdev_max_backlog；
    + 增大 TCP 半连接队列；
    + 开启 tcp_syncookies；
    + 减少 SYN+ACK 重传次数
    
    

14. TCP为什么是可靠的

    

    - 基于数据块传输：数据被分割成报文段进行传输

    - 为报文段赋予**序列号**保证有序

    - **校验和**：每个报文段事先计算好该报文段的校验和，接收方会基于收到的报文段重新计算校验和，如果不一致，将丢弃

    - 超时重传：发送方发送数据后如果在规定时间（RTO）内没有收到确认，则会重传对应的报文段

    - 流量控制：控制发送方的发送速率，保证接收方来得及接收

    - 拥塞控制：当网络拥塞时，减少数据的发送

      


15. TCP如何保证消息有序

    - 如上所述，每个TCP报文段会有一个唯一的序列号
    - 有了序列号接收方可以对消息进行排序

16. TCP的重传机制

    

<img src="https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403201804998.png" alt="在这里插入图片描述" style="zoom:50%;" />

- TCP维护一个合理的往返时间Round-Trip Time（RTT），超时时间RTO为一个略大于RTT的时间
- 超时重传：发送数据后在RTO内没有收到ACK就重传
- 快速重传
    - 如上图发送了5个报文，但Seq2丢失了，因此后续的报文接收到后回复了3个ACK2
    - 快速重传的工作方式是当收到三个相同的ACK报文时，会在定时器过期以前重传丢失的报文段

17. TCP中的流量控制与拥塞控制分别指的是什么

    - 流量控制：发送方不应发送的太快以至于接收方来不及接收
    - 拥塞控制：太多发送主机发送了太多数据或者发送速度太快，以至于网络无法处理

18. TCP如何实现**流量控制**

    - 流量控制是一种机制，用于限制发送方向接收方发送数据的速率，以防止接收方被过量的数据淹没，从而导致网络拥塞或接收方无法处理这么多的数据。

    - TCP实现流量控制的主要方法是使用滑动窗口协议。该协议允许发送方和接收方之间协商一个**窗口大小（即允许在未收到确认的情况下发送的未确认字节数）**，**发送方根据这个窗口大小发送数据**，而接收方在收到数据后会发送确认信息，以告知发送方可以发送的下一批数据的大小。

    - TCP实现流量控制的基本步骤：
        - **建立连接**：在TCP连接建立阶段，发送方和接收方会协商初始的窗口大小。这通常在TCP的三次握手过程中完成。
        - **发送数据**：发送方根据当前的窗口大小发送数据给接收方。发送方发送的数据量不会超过接收方允许的窗口大小。
        - **接收数据**：接收方收到数据后，将发送确认信息给发送方，确认收到的数据，并告知发送方允许发送的下一批数据的大小。
        - **更新窗口大小**：接收方可以根据自身的处理能力和接收缓冲区的情况来动态调整窗口大小，以便更有效地控制流量。
        - **处理超时**：如果发送方在一定时间内没有收到来自接收方的确认信息，将会触发超时重传机制，发送方会重新发送未确认的数据。




19. TCP如何实现拥塞控制

    + 前面的**流量控制**是**避免「发送方」的数据填满「接收方」的缓存**，但是并不知道网络的中发生了什么。

      一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。

      **在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大....**就有了**拥塞控制**，控制的目的就是**避免「发送方」的数据填满整个网络**

    + 怎么知道是否出现拥塞？

      + 只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是**发生了超时重传，就会认为网络出现了拥塞。**

    + 其实拥塞控制的四个算法：

      + 慢启动：：**当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。**慢启动的意思就是一点一点的提高发送数据包的数量。

      + 拥塞避免：拥塞避免算法后，它的规则是：**每当收到一个 ACK 时，cwnd 增加 1/cwnd。**

      + 拥塞发生

      + 快速恢复




#### 网络层

1. 网络层的常见协议有哪些

#### <font color=red>浏览器从输入地址到显示的全过程</font>

```shell
# 简单版本
- **浏览器查找域名的IP地址（DNS解析）**
    - 先检查浏览器缓存和本地是否有网址记录
    - 如果没有，查找本地域名服务器是否有网址记录
    - 如果没有，本地域名服务器将向根域名服务器发送请求，依次向上级服务器查询
    - 找到记录后，各级域名服务器缓存该记录方便后续查找
- **服务端请求与web服务器建立TCP连接，进行三次握手**
- **服务器处理请求，发回一个HTML响应**
- **浏览器解析HTML显示在前端页面**
```

- 网络连接过程
    - 通过动态主机配置协议（DHCP）获取IP地址，路由器地址和DNS服务器地址
    - 通过传输层UDP协议、网络层IP协议和链路层802.11将DHCP请求在局域网内广播
    - 服务器接收到请求后进行响应，发送相关信息，网络连接成功
- DNS解析
    - 递归查询，检查浏览器缓存、系统缓存、路由器缓存
    - 查找本地域名服务器缓存、根域名服务器、顶级域名服务器、主域名服务器缓存
- 建立TCP连接
    - 获取IP地址以后，浏览器向服务器指定端口发起TCP连接
    - 由应用层的交互向下流转到传输层的交互
    - 三次握手建立TCP连接
    - TCP对数据进行拆分，封装成报文段
- 网络层
    - 网络层负责转发和路由，确定数据传输的路径
    - 基于IP协议将报文段进一步封装为IP数据报并转发
- 链路层
    - 链路层负责节点-节点的传输
    - 基于地址解析协议（ARP）确定下一跳IP对应的MAC地址
    - 通过802.11等物理层协议完成传输
- 发送HTTP请求
    - 浏览器会发送一个HTTP GET请求，请求一个HTML文件
    - 如果是HTTPS请求，则在表示层通过TLS协议进行加密
        - 对称加密：只有一把公钥，用公钥加密，用公钥解密
        - 非对称加密：每个人有一把公钥一把私钥，用对方公钥加密，用自己私钥解密
        - 通过非对称加密传递公钥，通过对称加密交换信息
- 服务器响应
    - 收到请求后响应一个HTTP响应报文，包括相关响应头和响应体
- 浏览器解析HTML并绘制
- TCP四次握手断开连接
    - 现在的页面为了优化请求耗时，默认都会开启持久连接（keep-alive）
    - 当tab页关闭的时候才会断开连接



### 数据结构

互联网面试很多时候会问你：你最擅长哪一门课【计算机相关的】。此时你大概率只能回答：数据结构。因此数据结构相关的知识需要好好准备



1. 常见的排序算法有哪些

2. 你提到的排序算法的时间复杂度、空间复杂度、以及算法的稳定性大概清楚吗

    <img src="https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403071829667.png" alt="img" style="zoom: 33%;" />

3. 你能手写一个冒泡排序/插入排序/<font color=red>【快排】</font>吗

    ```shell
    # 可以参考我的算法笔记
    ```

4. 了解堆排序吗？能大概说下堆排原理吗？能实现一个吗【最后一个问题可以不用掌握】

    + **堆排序原理**：

      + 大根堆：每个结点的值都大于其左孩子和右孩子的节点的值
      + 小根堆：每个节点的值都小于其左孩子和有孩子的节点的值

    + **堆排序步骤**：

      + 将待排序的数组构成一个大根堆
      + 将顶端的数与末尾的数交换
      + 将剩余 n-1 个数再构造大根堆。

    + **堆排序python实现：**

      ```python
      """
      用堆排序实现topk问题
      """
      import heapq
      nums = [3,2,5,1,4,7,8]
      k = 3
      heapq.heapify(nums)
      for i in range(len(nums) - k):
          heapq.heappop(nums)
      
      print(nums)
      
      ```

      

5. 数组和链表有什么区别

6. 栈与队列有什么区别，分别有什么应用场景呢

7. 什么是树，二叉树，满二叉树，完全二叉树，平衡二叉树，二叉搜索树

8. 二叉树的各种遍历方式了解吗

9. 什么是哈夫曼树

10. 什么是红黑树，什么场景下能使用红黑树





### 数据库

#### 基本概念和相关语法

1. 数据库一些基本概念

    - 元组：tuple，关系数据库中的概念，关系是一张表，表中的每行是一个元组
    - 码：码就是能唯一标识实体的属性，对应表中的列
    - 候选码：关系中的某一属性或属性组能唯一标识一个元组，则称该组属性组为候选码
    - **主键（主码）：主码是从候选码中选出来的。一个实体集中只能有一个主码，但可以有多个候选码**
    - 外键：关系中的一个属性是另外一个关系中的主码，则该属性为外键
    - 主键用于唯一标识一个元组，不能重复，不能为空，一张表只有一个主键；外键是另一张表的主键，可以有重复的，可以为空，一张表可以有多个外键
    - 主属性：候选码中出现过的属性为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门），显然工号和身份证号都能唯一标识这个关系，所以都是候选码，工号、身份证号这两个属性就是主属性
    - 非主属性：不包含在任何一个候选码中的属性
    - ER图
        - 全称：Entity Relationship Diagram（实体关系图）
        - 三要素：实体、属性、关系
        - ![image-20230310094648718](https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202303100946353.png)

2. 数据库的三范式

    - 1NF：属性不可再分（关系数据库中创建的表一定满足第一范式）

    - 2NF：1NF的基础上，消除了非主属性对码的部分函数依赖（主要针对联合主键问题）

        - 有主键，非主键字段依赖主键

        - 第二范式确保表中每一列都和主键相关，而不能至于主键的子集相关

    
    ![第二范式](https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202403121953601.png)
    
    - 3NF：2NF的基础上，消除了非主属性对于码的传递函数依赖
    
        - 非主键字段不能相互依赖
    
        - 基本上解决了数据冗余、插入异常、修改异常、删除异常的问题
    
3. 数据库的分类

    - 关系型数据库（MySQL）
    - 非关系型数据库
        - 键值：键值数据库是一种较简单的数据库。是极为灵活的NoSQL数据库类型。Redis和DynanoDB是两款非常流行的键值数据库
        - 文档：文档数据库中的数据被存储在类似于JSON对象的文档中。每个文档包含成对的字段和值。它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB是一款非常流行的文档数据库
        - 宽列：宽列存储数据库非常适合需要存储大量的数据。常见宽列数据库：HBase
    
4. 关系数据库与非关系数据库的区别

    |              |                          SQL数据库                           |                         NoSQL数据库                          |
    | ------------ | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | 数据存储模型 |               结构化存储，具有固定行和列的表格               | 非结构化存储。<br />文档：JSON文档；键值：键值对<br />宽列：包含行和动态列的表 |
    | 例子         |                        Oracle、MySQL                         | 文档：MongoDB<br />键值：Redis<br />宽列：HBase<br />图表：Neo4j |
    | ACID属性     |              提供原子性、一致性、隔离性和持久性              | 通常不支持ACID事务，为了可扩展、高性能进行了权衡，少部分支持比如MongoDB。不过MongoDB对ACID事务的支持和MySQL还是有区别的 |
    | 性能         | 通常取决于磁盘子系统。要获得最佳性能通常需要优化查询、索引和表结构 |  性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定  |
    | 扩展         |  垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表  |      横向（增加服务器的方式横向扩展，通常基于分片机制）      |
    | 用途         |                  普通企业级的项目的数据存储                  | 用途广泛比如图数据库支持分析和遍历链接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化 |
    | 查询语法     |                    结构化查询语言（SQL）                     |                 数据访问语法可能因数据库而异                 |
    
5. SQL的分类

    - 数据定义语言（DDL, Data Definition Language）
        - 定义数据库对象
        - 核心指令：`create`、`alter`、`drop`
        
    - 数据操纵语言（DML, Data Manipulation Language）
        - 主要功能是访问数据，以读写数据库为主（Create、Read、Update、Delete）
        - 核心指令：`insert`、`update`、`delete`、`select`
        
    - 事务控制语言（TCL，Transaction Control Language）
        - 用于管理数据库中的事务
        - 核心指令：`commit`、`rollback`
        
    - 数据控制语言（DCL, Data Control Language）
        - 对数据访问权进行控制的指令，可以控制特定用户账户对数据表、查看表等数据库对象的控制权
        
        - 核心指令：`grant`、`revoke`
        
        - DCL以控制用户的访问权限为主，因此指令并不复杂
        
          

6. **执行一条 select语句，会发生什么**？

    1. 客户端与sql服务器通过Tcp通信协议三次握手，建立连接：

        ```
        mysql -uroot -p
        ```

        + 如何查看mysql服务被多少个客户端连接： `show processlist`

    2. 查询缓存：若击中缓存，直接返回数据

    3. 解析器：词法分析---语法分析----语法树

    4. 执行sql查询：**预处理器---优化器---执行计划（explain语句判断是否走索引）---执行器**

    5. 返回数据

    6. 四次挥手，断开连接

        <img src="img/image-20240403114113747.png" alt="image-20240403114113747" style="zoom:33%;" />

7. SQL的基本写法

    ```shell
    # 显示数据库列表
    mysql> show databases;
    # 进入数据库
    mysql> use my_data;
    # 显示数据库中所有表
    mysql> show tables;
    # 查看表内容
    mysql> select * from user;
    # 查看表结构
    mysql> desc user;
    ```

    创建新库/新表

    ```sql
    CREATE DATABASE test; # 建库
    DROP DATABASE test; # 删库
    USE test; # 选库
    ```
    
    ```sql
    # 建表
    CREATE TABLE user (
      id int(10) AUTO_INCREMENT PRIMARY KEY,
      username varchar(64) NOT NULL DEFAULT 'default' COMMENT '用户名',
      password varchar(64) NOT NULL DEFAULT 'default' COMMENT '密码',
      email varchar(64) NOT NULL DEFAULT 'default' COMMENT '邮箱'
    ) COMMENT='用户表';
    
    DROP TABLE user; # 删表
    ```
    
    ```sql
    # 修改表
    alter table user add age int(3);  # 添加列
    alter table user drop column age;  # 删除列
    alter table user modify column age tinyint;  # 修改列
    alter table user add primary key (id);  # 添加主键
    alter table user drop primary key;  # 删除主键
    ```
    
    插入数据
    
    ```sql
    # 插入一行
    insert into user 
    values (10, 'root', 'root', 'xxxx@163.com');
    # 插入多行
    insert into user
    values (10, 'root', 'root', 'xxxx@163.com'), (12, 'user1', 'user1', 'xxxx@163.com');
    # 插入一行的一部分
    insert into user (username, password, email)
    values ('admin', 'admin', 'xxxx@163.com');
    ```
    
    更新数据
    
    ```mysql
    update user
    set username='robot', password='robot'
    where username='root';
    ```
    
    删除数据
    
    ```sql
    #delete用于删除表中的记录
    delete from user
    where username = 'robot';
    ------------------------
    #truncate清空表
    truncate table user;
    ```
    
    查询数据
    
    - `distinct`用于返回唯一不同的值
    
    - `limit`限制返回的行数。可以有两个参数，第一个参数为起始行，从0开始；第二个参数为返回的总行数
    
    - `asc`升序（默认）；`desc`降序
    
      ~~~sql
      # 查询不同的值
          select distinct vend_id from products;
        
      # 限制查询结果
          -- 返回前5行
          select * from user limit 5;
          select * from user limit 0, 5;
          -- 返回第3-5行
          select * from user limit 2, 3;
          ```
      #排序
      
          select * from products
          order by prod_price desc, prod_name asc;
          
      #分组
          - `group by`子句将记录分组到汇总行中
          - `group by`为每个组返回一个记录
          - `group by`通常还涉及聚合`count`, `max`, `sum`, `avg`等
          - `group by`可以按一列或多列进行分组
          - `group by`按分组字段进行排序后，`order by`可以以汇总字段进行排序
          
          # 比如查询页面访问记录中，各个ip的访问次数
          select ip, count(*) as access_num
          from access_data
          group by ip;
         
          # 分组后排序,以降序排列ip的访问次数
          select ip, count(*) as access_num
          from access_data
          group by ip
          order by access_num desc;
          ```
      #这里就能看出`where`与`having`的区别：where在聚合之前进行过滤；having在聚合以后进行过滤
      
          #`having`：对汇总的`group by`结果进行过滤,查询分组后ip访问次数大于10的ip
          select ip, count(*) as access_num
          from access_data
          group by ip
          having access_num > 10
          order by access_num desc;
       
          # 'where': 只针对北京市的ip进行查询
          select ip, count(*) as access_num
          from access_data
          where province = '北京市'
          group by ip
          order by access_num desc;
      
      - and、or、not
      
          - 用于对过滤条件的逻辑处理指令
          - `and`优先级高于`or`
      
      - like
      
          -- 在where子句中使用，只有字段是文本值才使用`like`
          -- `like`支持两个通配符匹配选项：`%`和`_`:'%':可以表示多个字符，'_'只表示1个字符
          select prod_id, prod_name
          from products
          where prod_name like '%bean bag%';
      
      ~~~
    
7. MySQL中的连接

    - SQL join子句用于将两个或者多个表联合起来进行查询

        ```sql
        select table1.column1, table2.column2...
        from table1
        join table2
        on table1.common_column1 = table2.common_column2;
        ```
    
    - |      连接类型       |                            说明                            |
        | :-----------------: | :--------------------------------------------------------: |
        |  inner join 内连接  | （默认连接方式）只有当两个表都存在满足条件的记录才会返回行 |
        | left join 左外连接  |      返回左表所有行，即使右表中没有满足条件的行也返回      |
        | right join 右外连接 |                       返回右表所有行                       |
        |  full join 全连接   |        只要其中有一个表存在满足条件的记录，就返回行        |
    
8. 聚合函数中 `count(*)`, `count(1)`, `count(字段)` 有什么区别

    + `count(*)` 和 `count(1)` 一样，都是**统计表中有多少个记录**
    
    + `count(字段)`，统计该**字段**有多少个**不为空**的记录（not Null）
    
      

#### MySQL中的索引

1. 索引是一种用于**帮助存储引擎快速获取数据的一种数据结构**。（可以理解为一本书的目录）

   优点

   + 使用索引可以大大加快数据的检索速度

   - 通过创建唯一性索引，可以保证数据库表中的每一行数据的唯一性

   缺点

   + 创建索引和维护索引需要耗费时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低SQL的执行效率

   + 索引需要使用物理文件存储，也会耗费一定空间

     

2. **索引的分类**

   - 按照**数据结构**分类：B+tree 索引，Hash索引，Full-text索引

     <img src="img/image-20240403101041958.png" alt="image-20240403101041958" style="zoom:33%;" />

   - 按照**物理存储**分类：聚族索引（**主键索引**），二级索引（**辅助索引/非聚族索引**）：创建主键索引和二级索引默认使用B+树。

   - 按照**字段特性**分类：主键索引，唯一索引，普通索引，前缀索引：（在前缀索引中，字符串被分解为多个子串，并按照这些子串建立索引。这样可以快速地定位包含特定前缀的字符串，从而加速搜索和匹配过程。前缀索引的一种常见实现是前缀树（Trie））

   - 按照**字段个数**分类：单列索引，联合索引

   - 涉及索引的SQL

     ```sql
     create index user_index on user (id);  # 创建索引
     alter table user add index user_index(id);  # 添加索引
     create unique index user_index on user (id);  # 创建唯一索引
     alter table user drop index user_index;  # 删除索引
     ```

     

3. MySQL**索引的底层数据结构**是什么？为什么用B+树不用B树

   - B+树 vs B树

     - **B+树关键字数据都存在叶子结点，而B树的非叶子节点也要存储数据，所以B+树单个节点的数据量更小，在相同的磁盘I/O下，能查询更多的节点。**

     - **B+树天然具备排序：B+树叶子结点数据构成了一个双向链表**

     - 数据记录都存放在**叶子结点**中：叶子节点既有索引，也有数据记录：
       - 对于**主键索引**来说: **叶节点**除了**索引**之外，还包含了对应的**一条完整的数据记录**
       - 对于**二级索引**来说：叶节点除该**二级索引**之外，还包含了**主键值**
         - 如果查询的为主键，只用一次二级索引即可
         - 如果查询的内容除主键之外还有其他，由二级索引找到对应的主键索引，再返回主键索引的结果：称为回表。

   - B+树 vs 二叉树

     - 有 N 个叶子节点的 `B+Tree`，其搜索复杂度为`O(logdN)`，其中 d 表示节点允许的最大子节点个数为 d 个。（在实际应用中，d>100）。即使数据高达千万级别，B+树高度仍维持3-4层左右。（也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据）
     - 而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 `O(logN)`，这已经比 B+Tree 高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。

   - B+树 vs Hash

     - Hash 在做**等值查询**的时候效率贼快，搜索复杂度为 O(1)。

       但是 Hash 表**不适合做范围查询，它更适合做等值的查询**，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

       

4. MySQL的**存储引擎**有哪几种？

   |              | InnoDB                                                       | MyISAM                                                       |
   | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | 索引结构     | **B+树**：叶节点**只存储关键字**。表数据文件本身就是一个索引。 | **B+树**：叶节点存放指向表中**记录的指针**。索引文件与数据文件是分离的。 |
   | 是否支持事物 | 是/ 事物的ACID特性（银行业务）                               | 否                                                           |
   | 索引分类     | 聚族索引：索引项的顺序与表中记录的物理顺序一致               | 非聚族索引：索引顺序与表中数据的存储顺序无关                 |
   | 锁定         | 支持**行级锁定**，但是如果全表扫描，仍为表级锁定             | 支持**表级锁定**                                             |
   | 适用场景     | **mysql默认的存储引擎**。如果执行大量的插入/更新语句，较为适合（论坛/微博等频繁刷新的场景） | 读性能优越，写入性能较差                                     |

   

5. `InnoDB` **存储引擎选择索引的方式**

   - 有主键：默认使用主键作为索引键

   - 没有主键：选择第一个不包含 NULL值的一列作为索引键

   - 以上都不满足: 自动生成一个隐式自增 id 列作为索引键

     

6. 在MySQL中，`MyISAM引擎`和`InnoDB引擎`都是使用`B+Tree`作为索引结构。

   - InnoDB采用主键索引（聚簇索引），MyISAM采用二级索引（非聚簇索引）。

     + 主键索引的 B+Tree 的叶子节点存放的是**实际数据**，所有完**整的用户记录**都存放在主键索引的 B+Tree 的叶子节点里；
     + 二级索引的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据
       + **覆盖索引**：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引。
       + **回表**：会先检二级索引中的 B+Tree 的索引值（商品编码，product_no），找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。**这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据**。

   - 实例：主键索引/二级索引

     <img src="img/image-20240403104116437.png" alt="image-20240403104116437" style="zoom:33%;" />

     + 主键索引B+树：

       <img src="img/image-20240403104226255.png" alt="image-20240403104226255" style="zoom:33%;" />

     + 二级索引B+树：

       <img src="img/image-20240403104249325.png" alt="image-20240403104249325" style="zoom:33%;" />







#### 科学使用索引的原则

1. 什么时候适用索引？

   字段有**唯一性**限制的：如商品编码；

   经常用于`where`查询条件的字段；

   经常用于`group by` 和`order by`的字段

   

2. 什么时候不需要创建索引：

   字段值存在大量**重复**数据

   表中数据太少

   `where`, `group by`, `order by` 里用不到的字段

   经常更新的字段不用创建索引

   

3. 什么情况下索引会失效：

   使用**通配符**进行模糊匹配时：`like %xx%` 

   查询条件中对索引列进行计算，类型转换等操作

   **联合索引未遵循最左匹配原则**：假设有一个联合索引包含两列 `(A, B)`，按照最左匹配原则，如果查询条件中包含列 A，那么数据库可以使用这个索引来加速查询。但是，如果查询条件中只包含列 B 而不包含列 A，那么该索引可能无法被充分利用。

   where子句中, or前面索引列，而or后为非索引列

   

4. 优化索引的方法：

   限制每张表上的索引数量

   尽可能考虑建立联合索引而不是单列索引：索引是需要占用磁盘空间的，每个索引都对应着一个B+树。如果多个字段在一个索引上，将会节约磁盘空间

   在大多数情况下，都应该**尽量扩展已有索引**而不是创建新索引

   字符串类型的字段使用**前缀索引**代替普通索引

   防止索引失效，定期优化索引

   

5. 如何判断语句是否走了索引

   可以使用**`explain`命令**来**分析SQL的执行计划**

   执行计划是指一条SQL再经过MySQL**查询优化器**的优化后，具体的执行方式

   

6. 使用索引的基本流程

```sql
# 假设我现在为leetcode_statistics中的ac_number字段创建索引
create index ac_index on leetcode_statistics (ac_number);

# 分析语句是否走了索引
explain select date from leetcode_statistics where ac_number > 900;

# 现在要为该索引增加一个字段ac_hard_number
drop index ac_index on leetcode_statistics;  # 先删除原索引
alter table leetcode_statistics 
add index ac_index (ac_number, ac_hard_number);  # 创建新索引

# 分析语句是否走了索引
explain select date from leetcode_statistics where ac_number > 900 and ac_hard_number > 50;
explain select date from leetcode_statistics where ac_number >= 900 and ac_hard_number > 50
```

![image-20230312095759913](https://img-1300769438.cos.ap-beijing.myqcloud.com/images/202303120958111.png)

- 可以通过`key_length`字段来判断到底用了索引中的多少个字段，一个int字段一般为4，如果允许为空则为5
- 在使用`>`进行查找时，后面的字段将不再参与索引，而如果使用`>=`进行查找时，后面的字段仍参与索引
- 怎么知道查询语句走没走索引：`explain`语句



#### 事物

1. 什么是数据库中的事务？

   **事务是逻辑上的一组操作，要么都执行，要么都不执行；事务的目的，是保证数据一致性**

   + 举例：假设小明要给小红转账1000元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败

     将小明的余额减少1000元

     将小红的余额增加1000元

     事务会把这两个操作堪称逻辑上的整体，这个整体要么都成功，要么都失败

     数据库事务可以保证多个对数据库的操作构成一个逻辑上的整体，要么全部执行成功，要么全部不执行

     

2. 事务的四个要素分别是什么

   **Atomicity，原子性**：事务是最小的执行单位，不允许分割。事务的原子性保证动作要么全部完成，要么完全不起作用**

   **Consistency，一致性**：执行事务前后，数据保持一致。比如转账业务中，无论成功或失败，总额不应该有变

   **Isolation，隔离性**：并发访问数据库时，一个用户的事务不被其他事务所干扰

   **Durability，持久性**：一个事务被提交后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

   

   InnoDB引擎通过什么技术保证以上四个特性？

   - A: undolog(回滚日志)
   - C：A+C+D
   - **I: MVCC(多版本并发控制)/ 锁机制**
   - D：redolog(重做日志)

   只有保证了事务的原子性、隔离性和持久性，一致性才能得到保障

   

3. 事物并发可能会产生哪些问题

   一个mysql服务端可允许多个客户端连接，意味着mysql存在同时处理多个事务的情况。（严重性依次降低）

   **脏读（Dirty Read）：读到其他事物未提交的数据**

   - **读到其他事务未提交的数据，未提交意味着数据可能会回滚，导致读到了一条不存在的数据**

   - 举例：公司发工资，领导把5000元打到你的账户上，但还未提交；正巧你查看了银行账户发现到账5000元，你非常开心。不幸的事领导发现了他多打了一个0，于是立即回滚了数据，修改金额后，将事务提交；你空欢喜一场

   - 避免措施：事务B读取了事务A未提交的数据。将隔离级别设置为：Read Commited，就可以避免脏读

   **不可重复读（Unrepeatable Read）：前后两次读取的数据不一致**

   - 当设置A事务只能读取B事务已经提交的部分，会造成在**事务A内的两次查询结果不一样**，因为**两次查询期间事务B进行了提交操作**

   - 举例：你拿着工资卡去消费，系统读到卡里有500元，而此时你的老婆也正好在网上转账，你的老婆把卡里的余额全部转移到了另一个账户，并在你消费之前提交了事务。当你结账时居然发现卡里没钱了

   - 避免措施：将隔离级别设置为：Repeatable Read，就可以避免不可重复读

   **幻读（Phantom Read）：前后读取符合条件的记录数量不一致**

   - 在一个事务内多次查询某个符合**查询条件**的**记录数量**，若出现前后两次查询的**记录数量**不一致，出现幻读。

   - 举例：假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。

     然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，**发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读**

   - 当隔离级别设置为：Serializable，可以避免幻读（同时代价也很高，性能很低，这意味着所有事务将串行执行

     

4. 事务隔离级别，MySQL默认的隔离级别是什么

   **读未提交**（Read-Uncommitted）指一个事务还没提交时，它做的变更就能被其他事务看到。
   
   可能发生：脏读，不可重复读，幻读
   
   **读提交****（Read-Committed）：只允许读取并发事务已经提交的数据，可以**阻止脏读**。
   
   可能发生：不可重复读，幻读
   
   **可重复读**（Repeated-Read）：**对同一字段的多次读取结果是一致的：MySQL的默认隔离级别**
   
   可能发生：幻读
   
   **串形化**（Serializable）：最高隔离级别，完全服从ACID的隔离级别。所有事务依次逐个执行，这样事务之间就完全不可能产生干扰（完全规避问题）
   
   从上往下，隔离级别依次升高。但是隔离级别越高，性能效率越低。

   

#### 并发事务的控制方式-锁

+ 根据加锁的范围，分为行级锁，表级锁，全局锁

+ 全局锁：

  要使用全局锁，则要执行这条命令：

  ```sql
  flush tables with read lock
  ```

  执行后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：

  - 对数据的增删改操作，比如 insert、delete、update等语句；
  - 对表结构的更改操作，比如 alter table、drop table 等语句。

  如果要释放全局锁，则要执行这条命令：

  ```sql
  unlock tables
  ```

  + 全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

+ 表级锁：[MySQL 有哪些锁？ | 小林coding (xiaolincoding.com)](https://xiaolincoding.com/mysql/lock/mysql_lock.html#插入意向锁)

+ 行级锁





### 开发基本功



#### Linux相关操作

Linux的操作偏实战，涉及到指令相关的内容一定要在服务器上实际动手尝试几次

1. 如何连接服务器【ssh】

2. 目录相关操作：目录的切换、新建、删除、拷贝、移动/改名

    ```shell
    cd # 切换目录
    cd /  # 切换到根目录下
    cd ~  # 切换到当前用户的根目录下
    cd ..  # 切换到上一级目录下
    cd ../..  # 切换到上上级目录下
    
    mkdir
    rm -r your-dir # 递归地删除目录以及目录下的所有内容
    cp -r your-dir-path target-dir-path # 拷贝目录到指定位置
    mv your-dir-path target-dir-path # 移动目录到指定位置，也可以实现改名
    ```

3. 你平时怎么新建一个文件

    ```shell
    touch a.py # 新建一个a.py文件
    ```

4. 对文件的增删改查操作分别怎么实现

    ```shell
    vim a.py # 查看a.py文件内容，如果文件不存在则在当前文件夹创建该文件。如果需要修改内容，键盘按“e”键【英文模式，不要打中文输入】
    rm a.py # 删除文件
    vim a.py # 修改文件内容
    # 查看文件内容
    cat a.py # 显示整个文件内容
    more/less/tail a.py # 这些都可以实现查看文件内容
    tail -f log.txt # 这个命令可以动态的查看文件末尾【比如查看日志的动态更新】
    ```

5. 移动文件用什么命令

    ```shell
    mv ./a.py ~/a.py  # 将文件从当前文件夹，移动到你的根目录下
    mv ./a.py ./b.py # 将文件改名为b.py
    ```

6. 如何全局搜索一个文件/文件夹【find/grep】

    ```shell
    find . -name 1.py  # 在当前目录下查询“1.py”文件
    find ~ -name "1*"  # 在用户根目录下查询“1.py”文件
    grep "正" zxx  # 在zxx文件中搜索“正”字的出现行
    grep -r 贤 ../  # 在上一级文件夹搜索“贤”字的出现行
    ```

7. 如何查看/修改文件的权限【chmod】

8. 了解grep吗

9. 如何查看系统当前运行的进程

    ```shell
    # 以下两个都可以
    ps -ef
    ps aux
    ```

10. 如何查看指定进程

    ```shell
    # 在所有进程中搜索“mysql”进程
    ps aux | grep "mysql" 
    ```

11. 如何查看端口占用情况

    ```shell
    netstat -an # 查看所有端口占用
    lsof -i:27017 # 查看指定端口占用
    ```

12. 如何查看系统cpu/资源占用情况

    ```shell
    top
    ```



#### git相关操作

1. git是用来干什么的

2. git主要有哪几个分区【工作区、暂存区、版本库】

3. git的五种状态

    - 未跟踪（untracked）：新添加的文件，或被移除跟踪的文件

    - 未修改：从仓库签出的默认状态，修改后就是“已修改的状态

    - 已修改（modified）：修改了文件还没保存到数据库中

    - 已暂存（staged）：对已修改文件的当前版本做了标记

    - 已提交（committed）：数据已安全保存在本地数据库中

        

4. git操作的基本流程【使用git的大概流程】

    - 在新的项目上初始化git：`git init`

    - 将改动提交到暂存区：`git add .`

    - 将暂存区内容提交到版本库：`git commit -m "your commit comment"`

    - 将提交的内容推送到远程库：`git push`

    - 下次更新前，先从远程库中拉最新的代码：`git pull`

        

5. <font color=red>git fetch与git pull有什么区别</font>

    - `git fetch` 命令只是将远程仓库的更新下载到本地仓库，但不会自动合并或修改你的工作目录中的文件。

    - 它会将远程分支的更新存储在本地仓库中，你可以查看这些更新，并手动决定是否将其合并到本地分支中。

    - `git pull` 命令会从远程仓库下载更新，并将其合并到你当前所在的分支中。

    - 实际上，`git pull` 是 `git fetch` 和 `git merge` 命令的组合。它会首先执行 `git fetch` 来获取远程更新，然后自动执行 `git merge` 将这些更新合并到当前分支。

    - `git pull = git fetch + git merge`

        

6. git rebase与git merge有什么区别

    - `git merge` 将两个分支的更改合并为一个新的提交，并创建一个新的合并提交。这个合并提交将拥有两个父提交，代表了合并的两个分支的历史。

    - 合并提交保留了分支的历史，因此你可以清晰地看到哪些更改来自于哪个分支，并且能够追溯到合并点的所有父提交。

    - `git rebase` 会将当前分支上的提交依次挨个地应用到目标分支的最新提交上，然后将目标分支指向最新的提交。它会重写提交的历史，创建一个新的提交系列，使得分支的历史更加线性。

    - 通过重新应用提交，`git rebase` 可以产生一个更干净的提交历史，避免了合并提交。这样做可以使得提交历史更容易理解和管理。

    - `git merge` 适合保留分支历史和清晰地记录分支合并点，而 `git rebase` 适合创建更干净的提交历史，使得分支的整体历史更加线性和可读。

        

7. 切换分支的指令

8. 我发现代码写错了，我想回滚到上个版本，应该怎么做

9. 我想回滚到指定版本，应该怎么做

|           指令            |                             描述                             |
| :-----------------------: | :----------------------------------------------------------: |
|      git checkout .       | 撤销工作区（未暂存）修改，把暂存区恢复到工作区；如果没暂存，则撤销所有修改 |
|    git checkout HEAD .    | 撤销工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换工作区、暂存区 |
|         git reset         |                 撤销暂存区状态，不影响工作区                 |
|    git reset [commit]     |           回退到指定版本，清空暂存区，不影响工作区           |
|   git reset --hard HEAD   |             撤销工作区、暂存区修改，用当前最新版             |
| git reset --hard [commit] |           回退到指定版本，并重置工作区，暂存区内容           |





### 常考的代码题

Leetcode Hot100+剑指offer认真刷两遍，基本上能搞定一大半的面试代码题

#### ACM标准的笔试题输入写法

##### 输入一行字符串s

```python
s = input()
```

##### 输入一个数n

```python
n = int(input())
```

##### 一行输入多个数a,b,c

```python
a, b, c = [int(k) for k in input().split()]
```

##### 一行输入若干个数保存在数组中

```python
nums = [int(k) for k in input().split()]
```

##### 输入一个MxN的数字矩阵

```python
# 例如
# 第一行输入一个正整数n，代表nxn矩阵大小。
# 接下来的n行，每行输入n个用空格分隔的数字，用来表示矩阵。
n = int(input())
mat = []
for i in range(n):
    mat.append([int(k) for k in input().split()])
```

```python
# 又例如
# 输入一个只由01构成的矩阵
# 第一行输入正整数m,n，分别代表矩阵的行数和列数
# 接下来的m行，每行输入由“0”或“1”构成的长为n的字符串，表示矩阵当前行所存的数据
m, n = [int(k) for k in input().split()]
mat = []
for i in range(m):
    # 直接将字符串作为一行
    # mat.append(input())  
    # 或者将字符串转为数字保存
    tmp = []
	s = input()
    for k in s:
        tmp.append(int(k))
    mat.append(tmp)
print(mat)
```

##### 构建一个全零矩阵

```python
m, n = 3, 4
mat = [[0 for _ in range(n)] for _ in range(m)]
```





1. 手写快排

2. 三数之和

3. Top k问题【给你一个数组，输出数组前k个最大的数】

    ```shell
    # 题面
    给你一个数组nums和一个整数k，输出数组中前k大的数字（输出不需要按大小排列）
    题目保证k大于0，小于等于数组的长度
    
    # 实例
    输入：nums = [5, 1, 3, 4, 7, 2, 1], k = 3
    输出：[5, 4, 7]
    ```

4. 如何判断链表有环

5. 链表中删除第k个节点

6. 二叉树层序遍历

7. [基础全排列](https://leetcode.cn/submissions/detail/510995950/)

    ```python
    class Solution:
        def permute(self, nums: List[int]) -> List[List[int]]:
            self.ans = []
    
            def recur(arr, res):
                if not arr:
                    self.ans.append(res)
                    return
                for i, k in enumerate(arr):
                    tmp = res + [k]
                    recur(arr[:i] + arr[i+1:], tmp)
            
            recur(nums, [])
            return self.ans
    ```


8. 合并有序数组

    ```shell
    # 题面
    给定两个有序数组arr1和arr2，将两个数组合并成一个有序数组
    
    # 实例
    输入：arr1 = [1, 3, 4, 6, 6, 8], arr2 = [2, 3, 3, 4, 6, 7]
    输出：[1, 2, 3, 3, 3, 4, 4, 6, 6, 6, 7, 8]
    ```

9. 括号匹配问题

    ```shell
    # 判断字符串是否有效
    # 题面
    给定一个由'()[]{}'六个字符构成的字符串，判断该字符串是否是一个有效的
    一个有效的字符串需要满足以下条件之一：
    1. ()
    2. []
    3. {}
    4. 它可以表示为：AB，其中A、B均为有效的字符串
    5. 它可以表示为：(A)或[A]或{A}
    
    # 实例
    输入：{[()]}
    输出：True
    
    输入：()[()]{{}}
    输出：True
    
    输入：{(])}()
    输出：False
    ```


10. [基于前序遍历和中序遍历输出后序遍历]((https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/))





## 测试相关知识



1. **接口测试**：[接口测试常用工具及测试方法（新手篇）_前端接口测试-CSDN博客](https://blog.csdn.net/AI_Green/article/details/120443679)

     

    + **接口**：**一种是程序内部的接口**，比如方法与方法之间，模块与模块之间的交互，如想要在论坛上发帖，就要先进行登录。**一种是系统对外的接口**：比如想从服务器获取信息，不可能把数据库共享，只提供一个写好的方法/接口来获取数据。**前端和后端的交互就是通过接口来进行**。
    + 常见的接口有哪些：**http: api接口**。走http协议，通过**路径来区分调用的方法**，请求报文一般都是键值类型，相应报文为json串。**有get和post方法**。
    + 什么是**接口测试**：要测试不同情况下的**入参和出参信息**来判断接口是否符合要求。
      + **接口测试**需要根据接口文档上规范的**调用地址、请求参数、拼接报文、发送请求、返回检查结果**
        + 接口文档应包含: 接口说明、**请求地址、请求方法、请求参数说明、返回参数说明**
        + get请求：直接在浏览器里输入，使用url或者cookie来进行传参。一般用来获取数据。
        + post请求：将数据放在body中，数据量比较大。比get更为安全。一般用来发送数据。
        + http: 状态码
    + 接口测试的角度
      + 接口**正常功能**测试
      + 接口**异常功能**检验
      + 接口**边界测试**
      + 接口的安全性检验：参数加密（用户名和密码是否加密，是否容易破解）
      + 接口与**上下游**的交互：
        + 接口对下游的容错性验证
        + 接口对上游的联合测试
      + 接口的**并发性**测试
      + 接口的**兼容性**测试：
        + 前端、后端的兼容
        + 新功能对老功能的兼容

    + 根据业务逻辑来设计用例：bbs论坛
      + 登录错5次，等待10min继续登录
      + 新注册的用户过一段时间才能发帖
      + 删帖扣积分等

      

2. **储粮害虫网站的登录窗口**，应该从哪些方面进行测试

    ```shell
    1. 输入正确的用户名+密码/不正确/空
    2. 用户名和密码是否大小写敏感/首次登陆是否提示更改密码/密码是否为明文/是否具有时效性
    3. 正确的用户名+密码+正确的验证码
    4. --
    5. 密码输入框是否加密
    6. 密码是否有校验
    7. 更改密码后后端数据库是否会更新数据
    8. 安全性检验：用户密码后台存储是否加密、网络传输过程是否加密、密码是否具有有效期；同一用户在一台设备的多个浏览器登陆，是否互斥
    9. 性能压力测试：单用户登陆的响应时间、高并发场景下用户登陆的响应时间、高并发场景下服务器的监控指标是否符合预期
    10. 兼容性测试：不同浏览器；相同浏览器的不同版本；不同分辨率
    
    
    ```

    

3. 如何看待测试？软件测试的相关流程

    ```shell
    软件测试在软件开发过程中起着至关重要的作用，它是确保软件质量、稳定性和可靠性的关键步骤。
    1. 发现缺陷： 软件测试是发现软件中潜在问题和缺陷的主要方法。通过不同的测试方法，可以在软件发布前及时发现并解决问题，提高软件的质量。
    2. 确保质量： 通过测试，可以确保软件满足预期的需求和规格，从而提高软件的质量，减少用户在使用过程中遇到的问题。
    3. 节省成本： 及早发现并解决问题可以减少后期修复的成本。在软件发布前投入适当的测试工作，可以大大节省后期修复问题的开销。
    4. 提高用户满意度： 良好的软件质量可以提高用户对软件的满意度，增加用户忠诚度和口碑。
    ```

    ```shell
    软件测试的流程
    1. 需求评审： 理解产品的需求，确定测试的范围和目标。
    2. 测试计划： 制定测试计划，确定测试的策略、方法、资源和进度安排。
    3. 测试设计： 根据需求和规格编写测试用例和测试场景，设计测试数据。
    4. 测试环境搭建： 准备测试所需的硬件、软件和网络环境。
    5. 执行测试： 按照测试计划执行测试用例，记录测试结果并收集问题报告。
    6. 问题跟踪与修复： 管理测试过程中发现的问题，与开发团队合作进行问题修复。
    7. 回归测试： 在问题修复后，执行回归测试以确保修复的问题不会再次出现，并且不会对其他部分造成影响。
    8. 测试报告： 撰写测试报告，总结测试结果、问题统计和建议，向相关人员汇报测试情况。
    9. 测试完成和验收： 根据测试结果确定是否满足发布标准，完成测试阶段并进行验收。
    10. 持续改进： 分析测试过程中的经验教训，改进测试方法和流程，提高测试效率和质量。
    ```

4. 测试项目的具体工作

    ```shell
    1. 需求评审：理解被测试的产品/需求
    2. 技术评审：理解产品/需求背后的技术逻辑
    3. 编写测试用例
    4. 结合RD、PM开展测试用例的评审
    5. RD联调前提供冒烟用例
    6. 冒烟通过后执行测试计划，每日同步相关测试进度
    7. PM进行验收
    8. 验收后进行灰度放量
    9. 编写线上环境的测试用例
    10. 形成测试报告，总结复盘
    
    
    ```

5. 不同视角的软件性能与性能指标

    ```
    1. 不同视角
    #终端用户：用户进行业务操作时的主观响应时间
    系统响应时间：如数据库处理时间、网络传输时间、应用系统处理时间等
    前端展现时间：取决于用户端的处理能力
    
    #系统运维人员：通常考虑大量用户并发访问时的负载（火车票购票网站）：会在用户量与响应时间上优先选择用户量
    
    #软件开发人员：
    数据库：数据库表的设计是否高效、是否引入必要的索引、SQL执行计划是否合理等
    算法：核心算法是否高效、是否存在不合理的资源竞争
    架构：系统容量和性能的扩展、应用集群的可扩展性、缓存集群的可扩展性等
    
    2. 常用指标：
    **并发用户数：比如某系统最大在线用户数为2500人。其中，30%处于页面浏览状态（没有对服务器发起请求）、20%在填写订单（也没有对服务器发起请求），..., 甚至有30%的用户没有进行任何操作。真正对服务器产生压力的只有500个用户。
    业务层面的并发用户数：2500人
    服务器层面的并发用户数：500人
    
    **响应时间
    系统响应时间：网络传输时间、数据库访问时间等
    前端展示时间：前端收到服务器端返回的数据进行渲染所需要的时间
    
    **系统吞吐量：
    最能直接体现软件系统负载承受能力的指标。所有对吞吐量的讨论都必须以“单位时间”为基本前提
    
    3. 后端性能测试常用工具：LoadRunner（virtual user generator、 LoadRunner Controller、LoadRunner Analysis）
       前端性能测试常用工具：WebPageTest(是一个网站)
    ```

    

6. 如何准备测试数据

    ```shell
    #主流的方法：
    1. 通过API调用生成测试数据：
    前提是自己清楚调用了哪些API（直接问RD），然后可以跳过GUI界面的操作，直接调用后端的API生成测试数据。
    优点：
    测试数据准备的执行效率更高，跳过了耗时的GUI操作；
    可以保证创建的测试数据的准确性，原因是使用了和GUI操作同样的API调用
    把创建测试数据的API调用过程封装成测试数据函数更为方便
    
    缺点:
    不是每个测试数据创建都有对应的API支持
    需要按照一定的顺序一次性调用多个API，并且在多个API调用之间传递数据，无形中增加了测试数据准备函数的复杂性
    难以应对需要创建海量数据的场景
    
    2. 通过数据库操作生成测试数据：
    直接通过数据库操作，将测试数据插入到被测系统的后台数据库中；常见的做法是将创建数据需要用到的SQL语句封装成一个个的测试数据准备函数，当我们需要创建数据时，直接调用这些封装好的函数即可。
    
    优点：
    效率高，可以短时间创建大量的数据
    缺点：
    很多时候一个操作往往会修改很多张表，因此封装的数据准备函数的维护成本要高很多
    容易出现数据不完整的情况：比如一个业务操作实际上在一张主表和一张附表中插入了记录，但是基于数据库操作的数据创建可能只在主表中插入了记录，这种错误往往比较隐蔽。
    
    3. 综合运用API和数据库的方式生成测试数据
    ```

    

7. 软件测试的核心竞争力

    ```shell
    1. 设计全面的测试用例，能够覆盖所有可能的测试情况。不是把重点放在发现问题上
    2. 发现潜在的问题：所有人都能发现的问题，你发现了，这无法说明你在测试方面的能力；能发现别人发现不了的问题，就是你的价值所在
    3. 能够发现PRD中不合理之处，能够发现技术方案中不合理之处。不是说啥测啥，而是应该站在用户的角度考虑产品。
    ```

8. 测试和开发需要怎么结合才能使软件的质量得到更好地保障

    早期参与、持续交流、流程规范

    ```shell
    1. 早期参与，密切合作：测试人员应该参与到需求的技术评审中来，深入理解需求设计的技术架构和技术理论。能够针对技术方案中的不合理、不周全之处提出自己的见解。
    2. 制定标准的规范： 测试和开发团队应共同制定测试标准、流程，RD开发任务按照排期进行，尽量不挤压测试的时间。
    3. 单元测试及前后端联调： 开发人员应进行单元测试来验证其代码的正确性，确保通过冒烟用例。
    4. 尽早与RD、PM进行测试用例评审，确保三方对需求的理解一致，同时完善测试计划。
    5. 测试过程中每日与RD、PM同步测试进展，同时告知RD及时跟进测试中发现的问题。
    6. 追求质量
    7. 改进与反思
    ```

9. 说一说测试用例的边界

    ```shell
    边界值分析法就是对输入或输出的 --边界值以及边界值的邻域内--进行测试的一种黑盒测试方法。
    
    1. 对16bit的整数而言，32767与-32768是边界
    2. 屏幕上光标在最左上、最右下是边界
    3. 报表的第一行和最后一行
    4. 数组元素的第一个与最后一个
    5. 循环的第0次，第一次，倒数第一次
    ```

10. 如何写测试用例

    ```shell
    1. 常见的编写测试用例的方法，根据等价类划分（有效等价类，无效等价类）、边界值分析等方法找出大部分用例。
    2. 写好测试用例的基础：需求评审、技术评审都应参与，深入理解业务需求以及需求背后的技术逻辑
    3. 分功能模块去写测试用例，清楚输入、输出的各种可能性，按照MECE原则，做到不重复，不遗漏。
    4. 经常进行总结和回顾，梳理遗漏的测试点，总结原因不断内化为自身的经验。
    5. 书写格式要清晰，比如以思维导图的形式呈现。
    ```

11. 衡量测试用例好坏的指标

     ```
     覆盖全面！！！
     需求覆盖率
     代码覆盖率(计算代码覆盖率的工具：Java的Jacoco)
     ```

     

12. 什么是单元测试、集成测试、系统测试、验收测试、回归测试，其中最重要的是哪一步

     ```shell
     # chatgpt
     在软件开发中，单元测试、集成测试、系统测试、验收测试和回归测试是不同阶段的测试方法，用于确保软件质量。它们的主要目标和重点略有不同：
     
     单元测试（Unit Testing）：单元测试是针对软件中最小的可测试单元（通常是函数、方法或类）的测试。单元测试通常由开发者在编写代码时进行，最严格，最接近代码底层实现。（单元测试框架：Junit、TestNG）
     
     集成测试（Integration Testing）：集成测试是测试软件中不同模块之间的交互和集成情况。在这个阶段，测试重点是确保各个模块之间的接口和通信能够正常工作，以及模块集成后的整体功能是否符合预期。
     
     系统测试（System Testing）：系统测试是对完整的软件系统进行测试，以验证其是否符合需求并能够在目标环境中正常运行。系统测试关注软件的整体功能、性能、安全性、可靠性等方面，通常由测试团队执行。
     
     验收测试（Acceptance Testing）：验收测试一般由PM执行的测试，旨在验证软件是否满足用户的需求和预期。验收测试通常是最后一个测试阶段，在软件发布之前执行。
     
     回归测试（Regression Testing）：回归测试是在对软件进行修改或添加新功能后执行的测试，旨在确保新的更改没有破坏现有功能，并且整体软件系统仍然按预期工作。回归测试通常是自动化执行的，以确保效率和准确性。
     ```

13. 知道哪些测试类型

     ```shell
     测试可以分为功能测试和非功能测试
     非功能测试又可以分为：性能测试、压力测试、容量测试、资产安全性测试、兼容性测试、配置测试等等
     ```

14. 用过哪些测试方法

         1. 等价划分法
         2. 边值分析法
         3. 错误推测法
         4. 因果图法

15. 你觉得测试开发需要哪些知识，需要具备什么能力

         # 需要具备的知识
         1. 软件测试基础理论知识，了解测试框架，如JUnit等
         2. 编程语言基础，如C++/Java/Python等
         4. 计算机基础知识，如数据库，Linux，计算机网络等
         
         # 需要具备的能力
         1. 业务分析能力：分析整体业务流程、分析被测业务数据、业务模块
         2. 缺陷洞察能力：一般缺陷的发现能力、隐性问题的发现能力、连带缺陷的发现能力、发现隐患问题的能力
         3. 团队协作能力：合理进行人员分工、协调各方（前后端研发、产品、测试）解决问题、配合开发重现缺陷、出现问题勇于承担
         4. 专业技术能力：掌握测试基础知识
         5. 逻辑思考能力：判断逻辑的正确性，对可行性进行分析
         6. 问题解决能力：技术上的问题，工作中的问题，沟通问题
         7. 沟通表达能力：和技术人员、产品人员、上下级的沟通
         8. 宏观把控能力：有效控制测试时间、测试成本，有效指定测试计划，控制测试方向
         ```

16. 什么是自动化测试，有什么意义，需要做些什么

         ```shell
         自动化测试是利用软件工具和脚本来执行测试过程的一种方法。这些工具可以模拟用户交互、执行测试用例、生成测试报告等。自动化测试的主要目的是提高测试效率、减少人工测试的工作量、提高测试覆盖率，并且可以在较短时间内执行大量测试。
         
         自动化测试的优点：
         1. 提高测试效率：自动化测试可以长时间不间断的执行测试，适用于接口巡检等需要7*24小时不间断工作的状态，减少人工的压力。
         2. 可以大幅度提升回归测试的效率（为什么适合回归测试：回归测试需要在每次代码更新后重复执行相同的测试用例，以确保没有引入新的错误，保证老功能的正常使用）
         3. 适合需求稳定，不会频繁变更；在多种平台上运行重复测试；无人值守，24小时连续测试等场景
         
         自动化测试的缺点：
         1. 开发自动化测试软件/程序需要投入大量的精力，那么如果该测试场景使用率不高的情况下，进行自动化测试就得不偿失；
         2. 自动化测试对场景的适应性不够高，如果测试问题/测试场景有变化，原来的自动化测试工具不一定还有效；
         
         
         
         要实施自动化测试，需要进行以下几个步骤：
         1. 选择合适的自动化测试工具：根据项目需求和技术栈选择适合的自动化测试工具，如JUnit、TestNG等。
         2. 制定自动化测试计划：确定需要自动化的测试场景和用例，并制定相应的测试计划和策略。
         3. 编写测试脚本：使用选定的自动化测试工具编写测试脚本，以模拟用户操作和执行测试用例。
         4. 执行自动化测试：执行编写的自动化测试脚本，收集测试结果并生成测试报告。
         5. 定期维护和更新测试脚本：随着软件的迭代和变化，需要定期维护和更新自动化测试脚本，以确保其与软件功能保持同步。
         ```

17. 软件开发各阶段涉及的自动化技术

     ```
     单元测试：
     1. 被测代码自动化静态分析：识别出违反编码规则的代码行
     2. 用例框架代码生成的自动化：TestNG框架代码应该由自动化工具生成
     3. 代码覆盖率的自动统计与分析：代码覆盖率、分支覆盖率等
     ```

     

18. 什么是黑盒测试、白盒测试，它们分别有哪些方法

         ```shell
         黑盒测试和白盒测试是软件测试的两种基本方法，它们侧重于不同的测试角度和目标：
         
         1. 黑盒测试（Black Box Testing）：
         
            - 黑盒测试是一种基于软件功能规格和需求进行测试的方法。测试人员不需要了解软件的内部结构或实现细节，而是将软件看作一个黑盒子，只关注输入和输出之间的关系。
            
            - 黑盒测试的目标是验证软件是否按照规格说明和用户需求正常运行，而不关心内部实现细节。
            
            - 常见的黑盒测试方法包括等价类划分、边界值分析、决策表测试、状态转换测试、因果图等。
         
         2. 白盒测试（White Box Testing）：
         
            - 白盒测试是一种基于软件内部结构和实现细节进行测试的方法。测试人员需要了解软件的代码逻辑、数据结构和算法等内部信息。
            
            - 白盒测试的目标是验证软件的内部逻辑是否正确，以及代码是否按照预期执行。
            
            - 常见的白盒测试方法包括语句覆盖、分支覆盖、路径覆盖、条件覆盖、循环覆盖、数据流覆盖等。
         
         下面是它们的一些具体方法：
         
         1. 黑盒测试方法：
            - 等价类划分（Equivalence Partitioning）：将输入数据划分为等价的分组，从每个等价类中选择代表性的测试用例。
            - 边界值分析（Boundary Value Analysis）：针对输入的边界情况设计测试用例，包括最小边界、最大边界以及边界之间的值。
            - 决策表测试（Decision Table Testing）：根据不同的条件组合设计测试用例，以覆盖各种可能的情况。
            - 因果图（Cause-Effect Graph）：根据输入和输出之间的关系绘制因果图，并设计相应的测试用例。
         
         2. 白盒测试方法：
            - 语句覆盖（Statement Coverage）：确保每个代码语句至少被执行一次。
            - 分支覆盖（Branch Coverage）：确保每个分支路径至少被执行一次。
            - 路径覆盖（Path Coverage）：确保每个可能的执行路径都被覆盖到。
            - 条件覆盖（Condition Coverage）：确保每个条件的每个可能取值都被测试到。
            - 循环覆盖（Loop Coverage）：确保循环体被执行零次、一次和多次。
         ```

19. 如何对一个页面进行测试

         ```shell
         对一个页面进行测试可以采用多种测试方法和技术，具体选择取决于页面的类型、功能和需求。以下是一些可能的测试方法：
         
         1. **功能测试**：
            - **输入验证**：检查页面中的表单和输入字段是否能够正确接受、验证和处理用户输入。
            - **链接和导航**：验证页面链接是否正确导航到指定的位置，并确保导航功能正常。
            - **页面元素**：验证页面元素（如按钮、下拉菜单、复选框等）的可用性、可点击性和交互性。
            - **动态内容**：对于包含动态内容的页面，验证内容的加载、显示和更新是否正常。
         
         2. **界面测试**：
            - **布局兼容性**：在不同的浏览器、操作系统和设备上测试页面布局和样式，确保页面在各种环境下呈现一致。
            - **响应式设计**：针对不同的屏幕大小和分辨率测试页面的响应式设计，确保页面在各种设备上都能良好显示和交互。
         
         3. **性能测试**：
            - **加载时间**：测试页面的加载速度，包括首次加载时间和页面元素的加载时间。
            - **响应时间**：测试页面交互元素（如按钮点击、表单提交）的响应时间。
            - **并发访问**：测试页面在多个用户同时访问时的性能表现。
         
         4. **安全测试**：
            - **跨站脚本攻击（XSS）**：测试页面是否受到XSS攻击的风险，包括检查用户输入的过滤和编码。
            - **跨站请求伪造（CSRF）**：测试页面是否容易受到CSRF攻击，包括验证请求中的CSRF令牌。
         
         5. **用户体验测试**：
            - **易用性**：测试页面的易用性和用户友好性，包括页面布局、导航逻辑和用户交互方式。
            - **可访问性**：测试页面的可访问性，包括键盘操作、屏幕阅读器和辅助功能的支持。
         
         6. **兼容性测试**：
            - **浏览器兼容性**：测试页面在不同的浏览器（如Chrome、Firefox、Safari、Edge等）中的兼容性。
            - **操作系统兼容性**：测试页面在不同操作系统（如Windows、macOS、Linux等）中的兼容性。
         
         7. **集成测试**：
            - 对于页面依赖于后端服务或其他组件的情况，进行集成测试以确保页面与其依赖的组件正确集成。
         
         以上是一些常见的页面测试方法，具体选择和执行测试方法时应根据项目需求、页面特性和测试目标进行调整和优化。
         ```

20. 如何对朋友圈点赞功能进行测试

         ```shell
         对朋友圈点赞功能进行测试需要综合考虑功能、界面、性能、安全性等方面。以下是一些可能的测试步骤和方法：
         
         1. **功能测试**：
            - 点赞操作是否可以成功执行。
            - 检查用户对自己或他人发布的朋友圈是否可以进行点赞。
            - 点赞后，点赞按钮是否正确显示为已点赞状态。
            - 检查取消点赞操作是否可以成功执行，并且按钮状态正确显示为未点赞状态。
            - 点赞功能在不同网络条件下是否正常工作。
         
         2. **界面测试**：
            - 检查点赞按钮在各种屏幕大小和分辨率下的显示效果。
            - 确保点赞按钮的位置和样式符合设计规范，并且易于用户识别和操作。
         
         3. **性能测试**：
            - 测试点赞功能在大量用户同时操作时的性能表现，包括点赞速度和系统响应时间。
            - 测试点赞功能对系统服务器资源的占用情况，确保系统在高负载下仍能正常工作。
         
         4. **安全测试**：
            - 测试点赞功能是否容易受到恶意攻击，如通过脚本自动化点赞或刷赞。
            - 测试点赞功能是否受到跨站脚本攻击（XSS）或跨站请求伪造（CSRF）等安全漏洞的影响。
         
         5. **用户体验测试**：
            - 点赞功能的交互是否流畅，用户是否能够方便地进行点赞操作。
            - 测试点赞后的提示信息或动画效果是否清晰、友好，以提升用户体验。
         
         6. **兼容性测试**：
            - 测试点赞功能在不同的操作系统（如iOS、Android）、浏览器（如Chrome、Safari、Firefox）、设备（如手机、平板、PC）上的兼容性。
         
         7. **集成测试**：
            - 测试点赞功能与其他朋友圈功能（如评论、转发）的集成情况，确保各功能之间的协调和一致性。
         
         在进行测试时，可以结合使用手动测试和自动化测试，以提高测试效率和覆盖率。同时，根据具体的测试需求和项目特点，灵活调整测试策略和方法。
         ```

21. [对微信聊天框进行测试](https://blog.csdn.net/qq_45661125/article/details/120535162)

22. 测试开发的主要工作职责

      ```shell
      1. 测试策略设计：测试开发人员需要与测试团队合作，制定测试策略和计划，包括测试范围、测试目标、测试方法、测试环境、测试数据等方面的规划。
      2. 测试用例设计：测试开发人员需要根据测试计划和需求文档，设计和开发测试用例，包括功能测试、性能测试、安全测试、兼容性测试等方面的测试用例。
      3. 测试工具的开发：测试开发人员需要使用相应的编程语言，结合一些测试框架开发测试脚本，实现自动化测试流程。
      4. 测试环境搭建和维护：测试开发人员需要搭建和维护测试环境，包括测试服务器、测试数据库、测试数据等方面的工作。
      5. 测试结果分析和报告：测试开发人员需要对测试结果进行分析和报告，包括测试缺陷的分类、定位、跟踪和修复等方面的工作。
      
      总的来说，测试开发人员需要具备扎实的软件测试知识和技能，熟练掌握测试工具和编程语言，具有良好的沟通和协作能力，能够与测试团队和开发团队紧密合作，为软件质量保障提供全方位的支持。
      ```

      
