# 算法笔记

[toc]



---

## 搜索排序算法



<img src="https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png" alt="img" style="zoom: 33%;" />



### 冒泡排序（Bubble Sort）

**冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 **

**算法描述**

- 比较相邻的元素。如果第一个比第二个大，就交换它们两个；
- 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样<font color=aqua>在最后的元素应该会是最大的数</font>；
- 针对所有的元素重复以上的步骤，除了最后一个；
- 重复步骤1~3，直到排序完成。

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015223238449-2146169197.gif" alt="img" style="zoom:75%;" />

```c++
void bubble_sort(vector<int>& nums) {
    for (int i = nums.size(); i > 0; i--) {
        for (int j = 1; j < i; j++) {
            if (nums[j-1] > nums[j]) swap(nums[j-1], nums[j]);
        }
    }
}
```



### 选择排序（Selection Sort）

**选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先<font color=aqua>在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</font>，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 **

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015224719590-1433219824.gif" alt="img" style="zoom:75%;" />

```c++
void selection_sort(vector<int>& nums) {
    int len = nums.size();
    for (int i = 0; i < len; i++) {
        int min_val = nums[i], min_idx = i;
        for (int j = i + 1; j < len; j++) {
            if (nums[j] < min_val) min_val = nums[j], min_idx = j;
        }
        swap(nums[i], nums[min_idx]);
    }
}
```



### 插入排序（Insertion Sort）

**插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。**

**算法描述**

- 从第一个元素开始，该元素可以认为已经被排序；
- 取出下一个元素，在已经排序的元素序列中从后向前扫描；
- 如果该元素（已排序）大于新元素，将该元素移到下一位置；
- 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
- 将新元素插入到该位置后；
- 重复步骤2~5。

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015225645277-1151100000.gif" alt="img" style="zoom:75%;" />

```c++
void insertion_sort(vector<int>& nums) {
    int len = nums.size();
    for (int i = 1; i < len; i++) {
        int target = nums[i], j = i;
        for (; j > 0 && target < nums[j-1]; j--) {
            nums[j] = nums[j-1];
        }
        nums[j] = target;
    }
}
```



### 希尔排序（Shell Sort）

**1959年Shell发明，第一个突破 $ O(n^2)$ 的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序**。**

**在几种基础排序算法中，希尔排序不太容易理解，尝试理解希尔排序之前请先非常深入的理解插入排序的原理并能快速推出。初学者如果对希尔排序有困惑可以只记住大致的过程，暂时跳过代码实现**

**算法描述**

先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：

- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
- 按增量序列个数k，对序列进行k 趟排序；
- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。

![img](https://images2018.cnblogs.com/blog/849589/201803/849589-20180331170017421-364506073.gif)

**仔细观察会发现，希尔排序算法的核心部分就是插入排序算法，只是在基础上嵌套了一层`gap`逻辑**

```c++
void shell_sort(vector<int>& nums) {
    int len = nums.size();
    for (int gap = len / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < len; i++) {
            int target = nums[i], j = i;
            for (; j - gap >= 0 && target < nums[j-gap]; j -= gap) {
                nums[j] = nums[j-gap];
            }
            nums[j] = target;
        }
    }
}
```



### 归并排序（Merge Sort）

**归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。**

**算法描述**

- 把长度为n的输入序列分成两个长度为n/2的子序列；
- 对这两个子序列分别采用归并排序；
- 将两个排序好的子序列合并成一个最终的排序序列。

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230557043-37375010.gif" alt="img" style="zoom:75%;" />

**注意：归并排序需要开辟额外的辅助数组，逻辑比较复杂**

```c++
void _merge(vector<int>& nums, int left, int right, vector<int>& res) {
    int mid = (left + right) / 2 + 1;
    int l = left, ll = left, r = mid;
    while (l < mid or r <= right) {
        if (l < mid and r <= right) {
            if (nums[l] < nums[r]) res[ll++] = nums[l++];
            else res[ll++] = nums[r++];
        } else if (l < mid) res[ll++] = nums[l++];
        else res[ll++] = nums[r++];
    }
    for (int i = left; i <= right; i++) nums[i] = res[i];
}

void _split(vector<int>& nums, int left, int right, vector<int>& res) {
    if (left >= right) return ;
    int mid = (left + right) / 2;
    _split(nums, left, mid, res);
    _split(nums, mid + 1, right, res);
    _merge(nums, left, right, res);
}

void merge_sort(vector<int>& nums) {
    vector<int> res(nums.size());
    _split(nums, 0, nums.size() - 1, res);
}
```



### 快速排序（Quick Sort）

**快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。前面的排序算法都可以不掌握，但快排思想必须理解，这是基础排序算法中最重要的算法**

**算法描述**

- 从数列中挑出一个元素，称为 “基准”（pivot）；
- 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；
- 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。

<img src="https://images2017.cnblogs.com/blog/849589/201710/849589-20171015230936371-1413523412.gif" alt="img" style="zoom:75%;" />

```c++
void quick_sort(vector<int>& nums, int left, int right) {
    if (left >= right) return;
    int l = left, r = right;
    while (l < r) {
        while (l < r and nums[r] >= nums[left]) r--;
        while (l < r and nums[l] <= nums[left]) l++;
        swap(nums[l], nums[r]);
    }
    swap(nums[l], nums[left]);
    quick_sort(nums, left, l-1);
    quick_sort(nums, l+1, right);
}
```





### 二分搜索（Binary Search）

**在一个有序数组中，通过遍历查找某个数效率是很低的，可以采用二分的策略更快找到目标值**

```c++
// return index if found, else return -1
int binary_search(const vector<int>& nums, int target) {
    int left = 0, right = nums.size(), mid;
    while (left < right) {
        mid = (left + right) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    return !nums.empty() and nums[left] == target ? left : -1;
}
```

**C++中提供了一些内置函数可以辅助实现二分策略，不需要手动去写：**

```c++
int _binary_search(vector<int>& nums, int k) {
    if (nums.empty()) return -1;
    auto it = lower_bound(nums.begin(), nums.end(), k);
    return (*it == k and it - nums.begin() < nums.size()) ? int(it - nums.begin()) : -1;
}
```

**注：`lower_bound()`函数用于在指定区域内查找不小于目标元素的第一个元素；`upper_bound()`函数用来在指定区域查找大于目标元素的第一个元素**



### 二分插入（Binary Insert）

**二分插入与二分搜索的不同之处在于：如果目标元素没有出现在数组中，二分插入将会返回目标元素应该插入位置的索引**

```c++
// return index where target should be inserted.
int binary_insert(const vector<int>& nums, int target) {
    int left = 0, right = nums.size(), mid;
    while (left < right) {
        mid = (left + right) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    return left;
}
```





## 高频数据结构



### 前缀树Trie

**Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来解决在一组字符串集合中快速查找某个字符串的问题。**

**它的核心思想就是通过最大限度地减少无谓的字符串比较，使得查询高效率，即「用空间换时间」，再利用共同前缀来提高查询效率。**

<img src="https://gitee.com/wzhdx/images/raw/master/202112281013991.png" alt="未命名绘图 (10)" style="zoom:33%;" /> 

#### - 前缀树类的实现

[Leetcode 208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

```c++
class Trie {
private:
    vector<Trie*> children;
    bool is_word;

    Trie* search_prefix(string& prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) return nullptr;
            node = node->children[ch];
        }
        return node;
    }

public:
    Trie() : children(26), is_word(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) node->children[ch] = new Trie();
            node = node->children[ch];
        }
        node->is_word = true;
    }

    bool search(string word) {
        Trie* node = search_prefix(word);
        return node && node->is_word;
    }

    bool startsWith(string prefix) {
        return search_prefix(prefix);
    }
};
```



#### - 前缀树应用

[Leetcode 472. 连接词【前缀树+dfs】](https://leetcode-cn.com/problems/concatenated-words/)

**在一个字符串数组中找出可以由两个及以上字符串组合而成的长字符串**

```
输入：words = ["cat","dog","catdog"]
输出：["catdog"]
```

```c++
class Solution {
public:
    Trie* t = new Trie();
    bool dfs(string& s, int start) {
        if (s.size() == start) return true;
        Trie* node = t;
        for (int i = start; i < s.size(); i++) {
            char ch = s[i] - 'a';
            node = node->children[ch];
            if (node == nullptr) return false;
            if (node->is_word) {
                if (dfs(s, i + 1)) return true;
            }
        }
        return false;
    }
    vector<string> findAllConcatenatedWordsInADict(vector<string>& words) {
        vector<string> res;
        sort(words.begin(), words.end(), [&](const string& s1, const string& s2) { return s1.size() < s2.size(); });
        for (int i = 0; i < words.size(); i++) {
            string word = words[i];
            if (word.empty()) continue;
            if (dfs(word, 0)) res.push_back(word);
            else t->insert(word);
        }
        return res;
    }
};
```





### 堆







---

## 字符串问题

### 回文串问题

[Leetcode 5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

**遍历字符串，以当前字符串为中心进行考虑，注意分奇偶进行判断**

```c++
class Solution {
public:
    string longestPalindrome(string s) {
    	string res = s.substr(0, 1);
    	for (int i = 0; i < s.size(); i++) {
    		// Odd
    		{
    			int j = 1;
    			while (i - j >= 0 && i + j < s.size() && s[i-j] == s[i+j]) j++;
    			if ((j * 2 - 1) > res.size()) res = s.substr(i - j + 1, j * 2 - 1);
    		}
    		// Even
    		{
    			if (i + 1 >= s.size() || s[i] != s[i+1]) continue;
    			int j = 1;
    			while (i - j >= 0 && i + 1 + j < s.size() && s[i-j] == s[i+1+j]) j++;
    			if (j * 2 > res.size()) res = s.substr(i - j + 1, j * 2);
    		}
    	}
    	return res;
    }
};
```







---

## 数组问题



### 最长递增子序列（LIS）问题

**最长递增子序列指的是在一个数组中（严格）单调递增的最长的子序列。通过暴力搜索，可以在时间复杂度 $ O(n^2)$ 计算出结果，但我们可以把复杂度降低到 $ O(nlog n)$**

```c++
template <typename T>
int lis(vector<T>& elems) {
    vector<T> dp;
    for (auto e : elems) {
        auto it = upper_bound(dp.begin(), dp.end(), e); // upper_bound: >=; lower_bound: >
        if (it == dp.end()) dp.push_back(e);
        else *it = e;
    }
    return dp.size();
}
```

#### [Leetcode 300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

```shell
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

<img src="https://gitee.com/wzhdx/images/raw/master/202201131415739.png" alt="未命名绘图" style="zoom: 50%;" /> 

```c++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        vector<int> dp;
        for (int n : nums) {
            auto it = lower_bound(dp.begin(), dp.end(), n);
            if (it == dp.end()) dp.push_back(n);
            else *it = n;
        }
        return dp.size();
    }
};
```



#### [Leetcode 5959. 使数组 K 递增的最少操作次数（2021-12-19周赛压轴）](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/)

**这一题，考试的时候直接就看出来是要找序列的最长递增子序列，但是当时不会 $ O(nlogn)$ 复杂度的解法，一直卡了超时**

```c++
class Solution {
public:
    int lis(vector<int>& nums) {
        vector<int> dp;
        for (auto x : nums) {
            auto it = upper_bound(dp.begin(), dp.end(), x);
            if (it == dp.end()) dp.push_back(x);
            else *it = x;
        }
        return nums.size() - dp.size();
    }
    int kIncreasing(vector<int>& arr, int k) {
        int res = 0;
        for (int i = 0; i < k; i++) {
            vector<int> vec;
            for (int j = i; j < arr.size(); j += k) {
                vec.push_back(arr[j]);
            }
            res += lis(vec);
        }
        return res;
    }
};
```



### 字符串哈希

**字符串哈希用于判断两个子字符串（全都由小写字母组成）是否相等。26个字母结合26进制可以计算每个字符串的数值，如果两个字符串的数值相等则它们是相同的，这样将原本 $ O(n)$ 的时间复杂度直接降为了 $ O(1)$**

**如果能够确定一个字符串中没有重复出现的字符，那么可以进一步简化问题，将字符串表示为一个26位的二进制数（C++中用`int`类型表示即可）**

**字符串哈希是存在问题的，问题在于：当字符串特别长的时候，字符串对应的数字非常大，导致越界问题，这时可以考虑对数字取模，但取模后可能又会出现“碰撞问题”，因此最严谨的做法是进行<font color=red>双值哈希</font>，即：使用两个不同进制进行哈希运算，如果两个字符串的两个哈希值都一样，那么必然相等**

#### [Leetcode 1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)

**找出字符串中任意一个具有最长长度的重复子串**

```shell
输入：s = "banana"
输出："ana"
```

**通过暴力搜索可以在 $ O(n^2)$ 的时间复杂度计算出结果，但显然导致超时。因此本题需要通过二分+字符串哈希优化过程**

```c++
class Solution {
public:
    const int base = 26, mod = 1000000007;
    bool check(int length, string& s, string& res) {
        unordered_map<long, int> umap;
        long cur_val = 0, mul = 1;
        int left = 0, right = length;
        for (int i = 0; i < length; i++) {
            cur_val = (cur_val * base + (s[i] - 'a')) % mod;
            mul = mul * base % mod;
        }
        umap[cur_val] = left;
        while (right < s.size()) {
            cur_val = (cur_val * base - (s[left++] - 'a') * mul) % mod + mod;
            cur_val = (cur_val + (s[right++] - 'a')) % mod;
            if (umap.count(cur_val) && s.substr(left, length) == s.substr(umap[cur_val], length)) {
                res = s.substr(left, length);
                return true;
            }
            umap[cur_val] = left;
        }
        return false;
    }
    string longestDupSubstring(string s) {
        int left = 0, right = s.size(), mid;
        string res;
        while (left < right) {
            mid = (left + right) / 2;
            if (check(mid, s, res)) left = mid + 1;
            else right = mid;
        }
        return res;
    }
};
```









---

## 动态规划问题



### 一维DP问题

#### [Leetcode 198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/)

**你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。**

```shell
输入：[2,7,9,3,1]
输出：12
解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
     偷窃到的最高金额 = 2 + 9 + 1 = 12 。
```

**入门级动态规划算法题，虽然简单，但是一种最典型的动态规划问题，后续各种高难度的动归问题最终都化为了类似形式。**

**这一题dp的递推式为：**

$$
dp[i] = 
\begin{cases}
nums[0]& i = 0 \\
max(nums[0], nums[1])& i = 1 \\
max(dp[i-1], dp[i-2] + nums[i])& i > 1
\end{cases}
$$

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        if (nums.size() == 1) return dp.back();
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp.back();
    }
};
```



### 二维DP问题



#### [Leetcode 44. 通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)

```
'?' 可以匹配任何单个字符。
'*' 可以匹配任意字符串（包括空字符串）。
两个字符串完全匹配才算匹配成功。
```

```shell
输入:
s = "adceb"
p = "*a*b"
输出: true
解释: 第一个 '*' 可以匹配空字符串, 第二个 '*' 可以匹配字符串 "dce".
```

**考虑用二维DP解决问题，数组比字符串长度大1用来表示起始的未启动状态为`true`。<font color=red>`dp[i][j] = true`用来表示字符串的前`j`位可以用通配符的前`i`位匹配。</font>接下来考虑`pattern`的几种不同情况：**

- **如果`pattern[i]`为字母，则在`string`中找相同的字母，如果能找到，再看该字符前的字符串是否是匹配的，如果是则该字符也能被匹配（如图二所示）**
- **如果`pattern[i] = '*'`，则我们只需要看之前的通配符能匹配到什么位置，之前能匹配到的，使用`*`可以匹配后续的一切可能，所以从可之前可匹配的位置后的一整行都可以被匹配（图三）**
- **如果`pattern[i] = '?'`，仍然看前一位匹配到的位置，前一位只要能匹配上，这一位必然匹配上，即`true`可以向右下方走一位（图四）**

<div align="center">
	<img src="https://gitee.com/wzhdx/images/raw/master/202112161904794.png" alt="水印_屏幕快照 2020-07-05 下午2.03.39.png" style="zoom: 33%;" /><img src="https://gitee.com/wzhdx/images/raw/master/202112161905920.png" alt="gaitubao_屏幕快照 2020-07-05 下午2.09.44.png" style="zoom:33%;" /><img src="https://gitee.com/wzhdx/images/raw/master/202112161906012.png" alt="gaitubao_屏幕快照 2020-07-05 下午2.20.13.png" style="zoom:33%;" /><img src="https://gitee.com/wzhdx/images/raw/master/202112161906735.png" alt="gaitubao_屏幕快照 2020-07-05 下午2.44.25.png" style="zoom:33%;" />
</div>

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int s_size = s.size(), p_size = p.size();
        vector<vector<bool>> dp(p_size + 1, vector<bool>(s.size() + 1, false));
        dp[0][0] = true;
        for (int i = 0; i < p_size; i++) {
            if (p[i] == '*') {
                for (int j = 0; j <= s_size; j++) if (dp[i][j]) dp[i+1][j] = true;
                for (int j = 0; j < s_size; j++) if (dp[i][j]) {
                    for (int k = j; k < s_size; k++) dp[i+1][k+1] = true;
                }
            } else if (p[i] == '?') {
                for (int j = 0; j < s_size; j++) if (dp[i][j]) dp[i+1][j+1] = true;
            } else {
                for (int j = 0; j < s_size; j++) if (dp[i][j] and p[i] == s[j]) dp[i+1][j+1] = true;
            }
        }
        return dp.back().back();
    }
};
```



#### [Leetcode 10. 正则表达式匹配](https://leetcode-cn.com/problems/regular-expression-matching/)

```shell
'.' 可以匹配任何单个字符。
'*' 匹配零个或多个前面的那一个元素
两个字符串完全匹配才算匹配成功。
```

```shell
输入：s = "aab" p = "c*a*b"
输出：true
解释：因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```

**这一题比通配符匹配要稍复杂一点，主要复杂在对符号`*`的讨论中。在正则表达式匹配中，`*`可以取任意数量的前一字符（包括0个），所以当前行的取值不仅仅依赖于上一行，也有可能是上2行的数据（因为前一个元素可以不取），只有这个地方容易出问题，其他地方几乎是完全一致的**

**如果这一题做起来很吃力的话请务必先理解前一题：通配符匹配**

```c++
class Solution {
public:
    bool isMatch(string s, string p) {
        int s_size = s.size(), p_size = p.size();
        vector<vector<bool>> dp(p_size + 1, vector<bool>(s_size + 1));
        dp[0][0] = true;
        for (int i = 0; i < p_size; i++) {
            if (p[i] == '*') {
                for (int j = 0; j <= s_size; j++) if (dp[i][j] or dp[i-1][j]) dp[i+1][j] = true;
                if (p[i-1] != '.') {
                    for (int j = 0; j < s_size; j++) if (dp[i][j]) {
                        while (p[i-1] == s[j] and j < s_size) {
                            dp[i+1][++j] = true;
                        }
                    }
                } else {
                    for (int j = 0; j < s_size; j++) {
                        if (dp[i][j]) {
                            for (int k = j; k < s_size; k++) dp[i+1][k+1] = true;
                            break;
                        }
                    }
                }
            } else if (p[i] == '.') {
                for (int j = 0; j < s_size; j++) if (dp[i][j]) dp[i+1][j+1] = true;
            } else {
                for (int j = 0; j < s_size; j++) if (dp[i][j] and p[i] == s[j]) dp[i+1][j+1] = true;
            }
        }
        return dp.back().back();
    }
};
```









#### [Leetcode 689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)

**给你一个整数数组 `nums` 和一个整数 `k` ，找出三个长度为 `k` 、互不重叠、且 `3 * k` 项的和最大的子数组，并返回这三个子数组。**

```shell
输入：nums = [1,2,1,2,6,7,5,1], k = 2
输出：[0,3,5]
解释：子数组 [1, 2], [2, 6], [7, 5] 对应的起始下标为 [0, 3, 5]。
也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。 
```

<img src="https://gitee.com/wzhdx/images/raw/master/202112082243963.png" alt="未命名绘图 (4)" style="zoom:50%;" />

**我们可以先利用前缀和的算法算出连续k个数的和形成的数组如下：**

<img src="https://gitee.com/wzhdx/images/raw/master/202112082314087.png" alt="未命名绘图 (4)" style="zoom:50%;" />

**现在问题就变成了在这个新数组`pre_sum`中挑三个数，和最大，前提是挑的数必须间隔`k-1`位。在上面的示例中最后挑选的三个数的下标就为`(0, 3, 5)`。如何找到三个数的最大和及他们的下标？**

**先考虑如何找到最大的和，这个问题和 [Leetcode 198. 打家劫舍](https://leetcode-cn.com/problems/house-robber/) 类似，是一个典型的动态规划问题，不同的是，这道题要求只能取三个数，难度有所增加。我们可以考虑开辟一个二维数组，初始全0，数组的维度为：`(pre_sum.size(), 4)`，4列分别表示在当前下标已经选取的数的数量。还是以上面的示例为例，此数组的dp数组结果如下（灰色方块没有意义）：**

<img src="https://gitee.com/wzhdx/images/raw/master/202112091008452.png" alt="未命名绘图 (5)" style="zoom:50%;" />

**当`idx = 0`时，只有可能选中`pre_sum[0]`或者不选，不选就是0，选了就是3（pre_sum[0] = 3），不存在选2个或3个**

**当`idx = 1`时，由于至少要间隔一个数字，所以选`pre_sum[1]`就不能选`pre_sum[0]`了，因此仍然最多只能选中1个，选1的位置应该是`max(dp[i-1][j], pre_sum[i]`，取二者的最大值，在这一题中都是3**

**当`idx = 2`时，选1的逻辑同`idx = 1`，但我们还可以选两个，选两个的逻辑为：`max(dp[i-1][2], dp[i-k][2-1]`，即不选当前值或者选当前值；不选当前值那么就是上一个下标选两个的结果，选当前值就是前k个下标选一个的结果加上当前的`pre_sum[i]`的结果**

**综上所述，我们可以得到动态规划的递推关系：**

$$
dp[i][j] = 
\begin{cases}
max(dp[i-1][j], pre_sum[i])& i < k\\
max(dp[i-1][j], dp[i-k][j-1] + pre_sum[i])& i \geq k
\end{cases}
$$

**基于上述规则一直推到最后一个元素，数组最后的值就是可以获得的最大值**

**然而题目并不要求返回最大的结果，而是返回字典序最小的下标，因此我们还需要根据最大值倒推下标。倒推的逻辑是：从dp数组末尾开始考虑，如此题中的`dp[6][3] = 23`，考虑这个23是否是结合了`pre_sum[6]`的值得来，如果结合了这个值，则这是目标下标中的一个，然后再考虑`dp[5][2]`，如果没有结合这个值，则说明这个下标没有用到，转而考虑`dp[5][3]`，这一部分的代码逻辑如下：**

```c++
// 倒推下标
int i = pre_sum.size() - 1, j = 3;
while (j > 0) {
    if ((i >= k and dp[i][j] > dp[i-k][j-1] + pre_sum[i]) or (i < k and dp[i][j] != pre_sum[i])) i--;
    else {
        res.push_back(pre_sum.size() - i - 1);
        j--, i -= k;
    }
}
```

**但是如果有多个下标组合都能构成最大值，我们倒推却只能得到字典序最大的那一组下标。为了解决这个问题，我们直接将原始数组逆序，然后在把下标放到结果数组之前逆序回来就可以得到字典序最小的下标了**

**完整代码：**

```c++
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int>& nums, int k) {
        reverse(nums.begin(), nums.end());
        // 构建前缀和
        vector<int> pre_sum {nums[0]};
        for (int i = 1; i < nums.size(); i++) pre_sum.push_back(pre_sum.back() + nums[i]);
        for (int i = nums.size() - 1; i >= k; i--) pre_sum[i] -= pre_sum[i-k];
        pre_sum.erase(pre_sum.begin(), pre_sum.begin() + k - 1);
        // 建立dp
        vector<vector<int>> dp(pre_sum.size(), vector<int>(4, 0));
        dp[0][1] = pre_sum[0];
        for (int i = 1; i < pre_sum.size(); i++) {
            for (int j = 1; j < 4; j++) {
                if (i >= k) dp[i][j] = max(dp[i-1][j], dp[i-k][j-1] + pre_sum[i]);
                else dp[i][j] = max(dp[i-1][j], pre_sum[i]);
            }
        }
        vector<int> res;
        // 倒推下标
        int i = pre_sum.size() - 1, j = 3;
        while (j > 0) {
            if ((i >= k and dp[i][j] > dp[i-k][j-1] + pre_sum[i]) or (i < k and dp[i][j] != pre_sum[i])) i--;
            else {
                res.push_back(pre_sum.size() - i - 1);
                j--, i -= k;
            }
        }
        return res;
    }
};
```



---

## 快速幂问题



[Leetcode 50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)

**举例：计算 $2^{14}$，我们可以先计算 $2^7$，接着我们可以计算 $2^3$（$2^7 = 2^3 \times 2^3 \times 2$），接着计算 $2^1$，以递归的方式一步一步缩小范围最后得到结果。这种思路由递归代码实现如下：**

```c++
// 递归实现快速幂
class Solution {
public:
    double qpow(double x, long long n) {
        if (n == 0) return 1;
        double y = qpow(x, n / 2);
        return n % 2 ? y * y * x : y * y;
    }
    double myPow(double x, int n) {
        long long N = n;
        return N > 0 ? qpow(x, N) : 1 / qpow(x, -N);
    }
};
```

**递归使用了额外的栈空间，实际上快速幂完全可以通过迭代实现**

<img src="https://gitee.com/wzhdx/images/raw/master/202112061657202.png" alt="未命名绘图 (2)" style="zoom:50%;" />

```c++
// 直接迭代实现快速幂
class Solution {
public:
    double myPow(double x, int n) {
        double res = 1, contribution = x;
        for (long i = abs(n); i > 0; i >>= 1) {
            if (i & 1) res *= contribution;
            contribution *= contribution;
        }
        return n > 0 ? res : 1 / res;
    }
};
```



### 秦九韶算法

[Leetcode 372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

**计算 $a^b$ 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出**

$$
乘法取模的分配律：(a⋅b)\  \% \ m = [(a\ \%\ m)⋅(b\ \%\ m)]\ \%\  m
$$

**将指数`b`看作一个数组考虑：**

$$
\begin{align}
假设\ \ b &= [4, 5, 6] \\ \\
n &= \sum_{i = 0}^{m - 1} 10 ^{m - 1 - i} \cdot b_i \qquad\qquad\qquad\qquad (456 = 10^2 * 4 + 10^1 * 5 + 10^0 * 6) \\
 &= (\sum_{i = 0}^{m - 2} 10^{m - 2 - i} \cdot b_i) \cdot 10 + b_{m-1} \qquad\  (456 = (10^1 * 4 + 10^0 * 5) * 10 + 6) \\ \\
 记\quad n^{'} &= \sum_{i = 0}^{m - 2} 10^{m - 2 - i} \cdot b_i \\ \\
superPow &= \begin{cases}
	1& \text{m = 0} \\
	superPow(a, b^{'})^{10} \cdot a^{b_{m - 1}}& \text{m > 0}
\end{cases}
\end{align}
$$

**上式即标准的秦九韶算法。再给一个例子辅助理解：**

$$
2^{456} = 2^{400} * 2^{50} * 2^6 = (2^{40} * 2^5)^{10} * 2^6 = ((2^4)^{10} * 2^5)^{10} * 2^6
$$

**根据上式，我们只需要每次从括号最内部（即指数最高位）开始迭代即可（中间需要不停地取模，否则数字越界）**

```c++
class Solution {
public:
    int qpow(int a, int b) {
        int contribution = a, res = 1;
        for (; b > 0; b >>= 1) {
            if (b & 1) res = (long) res * contribution % 1337;
            contribution = (long) contribution * contribution % 1337;
        }
        return res;
    }
    int superPow(int a, vector<int>& b) {
        int res = 1;
        for (int n : b) {
            res = (long) qpow(res, 10) * qpow(a, n) % 1337;
        }
        return res;
    }
};
```



### 费马-欧拉定理

**欧拉定理是数论中一个非常重要的定理：若正整数 $a$ 与 $m$ 互质，则：**

$$
a^{\phi(m)} \equiv 1 \quad (mod\  m)
$$

**这里的 $\phi(m)$ 是欧拉函数，即小于或等于m且与m互质的正整数个数。**

$$
\phi(m) = 
\begin{cases}
	m - 1& \text{m为质数}\\
	\phi(m_1)\phi(m_2)& m_1\cdot m_2 = m，m_1,m_2互质且不相等\\
	m * \prod(1 - 1/p)& p为质数且整除m
\end{cases}
$$

$$
\begin{align}
\phi(7) &= 7 - 1 = 6 \\
\phi(12) &= 12 * \frac{1}{2} * \frac{2}{3} = 4 \\
\phi(1337) &= \phi(7) \times \phi(191) = 6 * 190 = 1140
\end{align}
$$

**当m是质数时，欧拉定理退化成费马小定理，即欧拉-费马定理：**

$$
a^{p-1} \equiv 1\quad (mod \ p)
$$

**在算法竞赛中，我们经常会用到它的一个重要推论：若正整数a与m互质，则：**

$$
a^b = a^{\phi(m) \lfloor b / \phi(m) \rfloor + b \ mod \ \phi(m)} \equiv 1 \cdot  a^{b\ mod \ \phi(m)} \equiv a^{b\ mod \ \phi(m)}\ \ (mod\ m)
$$

**利用这个推论，即使b比较大，我们也可以轻松的计算 $a^b \ mod \ m$ 的值，但需要满足a与m互质的前提**

**为了解决a与m不互质的问题，又引入了扩展欧拉定理：**

$$
若\ b\geq \phi(m),\ 则：a^b \equiv a^{b\ mod\ \phi(m) + \phi(m)}\ \ (mod\ m)
$$

[Leetcode 372. 超级次方](https://leetcode-cn.com/problems/super-pow/)

<font color=aqua>**计算 $ a^b $ 对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出**</font>

**仍然考虑这一题，在这一题中`m = 1337`，注意这不是一个质数, $ \phi(m) = 1140$。因此此题是不能采用欧拉定理求值的（欧拉定理成立的条件是底数a与模数m互质，但在这里由于模1337不是质数，因此总能找到一个底数，使得其与m有公因子（不互质）。所以，这一题必须采用扩展欧拉定理实现，而实际上，扩展的欧拉定理也只是在原定理的基础上在指数上加上一个常量 $ \phi(m)$ 即可，在下面代码中，这一步的实现为：`m += phi;`，如果没有这一步，当底数a取7时答案将不正确**

**超大数取模运算可以简化为下面的代码表示：**

```c++
for (int i : b) {
    m = ((m * 10) + i) % phi;
}
```

**上面的代码与我们在纸上作除法运算的过程完全一致，即：从高位向低位走，只要大于被除数m，就取一次模，然后继续向低位走，最后可以得到余数**

**下面给出完整代码：**

```c++
class Solution {
public:
    int qpow(int a, int b) {
        int contribution = a, res = 1;
        for (; b > 0; b >>= 1) {
            if (b & 1) res = (long) res * contribution % 1337;
            contribution = (long) contribution * contribution % 1337;
        }
        return res;
    }

    int superPow(int a, vector<int>& b) {
        int m = 0, phi = 1140;
        for (int i : b) {
            m = ((m * 10) + i) % phi;
        }
        m += phi;
        return qpow(a % 1337, m);
    }
};
```





---

## 二叉树问题









---

## 连通图问题



### 最短路问题

<img src="https://gitee.com/wzhdx/images/raw/master/202203131423355.png" alt="未命名绘图 (2)" style="zoom:50%;" />

**在一个有向图中如何找出两个点（如0-->5）的最短路径？常见的方法是Dijkstra法**

```c++
typedef pair<int, int> pii;
struct edge {
    int dest, weight;
};

vector<int> dijkstra(int start, int n, vector<vector<int>>& edges) {
    vector<vector<edge>> G(n);
    for (auto &vec : edges) {
        G[vec[0]].push_back({vec[1], vec[2]});
    }

    vector<int> dist(n, INT_MAX);
    dist[start] = 0;

    priority_queue<pii, vector<pii>, greater<pii>> pq;
    pq.push({0, start});
    while (!pq.empty()) {
        auto elem = pq.top(); pq.pop();
        int weight = elem.first, begin = elem.second;
        if (dist[begin] < weight) continue;
        for (auto &e : G[begin]) if (dist[e.dest] > weight + e.weight) {
            dist[e.dest] = weight + e.weight;
            pq.push({dist[e.dest], e.dest});
        }
    }
    return dist;
}
```









### 节点连通性

<img src="https://gitee.com/wzhdx/images/raw/master/202112102106655.png" alt="未命名绘图 (7)" style="zoom:50%;" />

**在上面的图中，假设从A点出发，找出所有可到达的节点，应该怎么找？**

- **我们可以先将图中的所有边表示为一个`unordered_map`，将可到达节点放置在集合`unordered_set`中，则初始状态如下：**

<img src="https://gitee.com/wzhdx/images/raw/master/202112111343478.png" alt="未命名绘图 (8)" style="zoom:50%;" />

- **然后我们构建一个队列`queue`，遍历`edge_map`中的点，并把所有出现在`reach_point`中的点入队（在上面的情形下只有`A`入队）**
- **接着遍历队中元素，逐个元素出队，出队的同时将与该点有连接的、尚未出现在`reach_point`中的点入队**
- **当队空时结束判定，此时所有可从A点到达的点就全部出现在`reach_point`中了**

**代码实现如下：**

```c++
void detect(unordered_set<int>& res_set, unordered_map<int, vector<int>>& umap) {
    queue<int> q;
    for (auto& kv : umap) if (res_set.count(kv.first)) q.push(kv.first);
    while (!q.empty()) {
        int point = q.front();
        q.pop();
        for (int num : umap[point]) if (!res_set.count(num)) {
            res_set.insert(num);
            q.push(num);
        }
    }
    umap.clear();
}
```





### 并查集

**并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些元素分组的问题。它管理一系列不相交的集合，并支持两种操作：**

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

**并查集的重要思想在于：用集合中的一个元素代表集合**

<div align="center">
	<img src="https://pic4.zhimg.com/80/v2-09fa3fa35e5411444b327d9cb9a31057_1440w.jpg" alt="img" style="zoom: 50%;" /><img src="https://pic4.zhimg.com/80/v2-be12a6c795572d2acd77dcd49de35127_1440w.jpg" alt="img" style="zoom:50%;" />
</div>
**可以把各个点理解为各个大侠，每个大侠属于一个帮派。在初始状态下，所有的点都是不连通的，这种情况下所有人各自为战，每个人都是一个不同的帮派，每个人也都是帮派的首领**

**当开始建立连接时，两个帮派就发生了合并，发生合并的结果就是两个帮派指向了同一个首领。简单来说，每个人会一层一层地往他的上级（leader）指，最后指向的是此帮派的首领，首领只会指向自己。因此如果两个人属于同一帮派，则它们往上指，最后的首领一定是同一个人**

**这就是最简单的并查集逻辑，我们可以用代码实现如下：**

```c++
// 1~n表示有n个大侠，fa[i]表示每个大侠的leader，初始情况下每个大侠的leader就是自己
void init(vector<int>& father, int n) {
    for (int i = 1; i <= n; ++i) fa[i] = i;
}
```

```c++
// 搜索一个大侠所在帮派的首领（如果两个大侠首领相同则同属一个帮派）
int find(vector<int>& father, int x) {
    return father[x] == x ? x : find(father, father[x]);
}
```

```c++
// 合并操作，当两个大侠产生了联系，各自的帮派进行合并（其中一个帮派的首领指向另一个帮派首领）
void merge(vector<int>& father, int i, int j) {
    father[find(father, i)] = find(father, j);
}
```

**路径压缩：上面的并查集算法存在效率问题，即在每次查找的过程中都必须遍历完整的一条路径，复杂度很高，如果可以直接指向帮派首领，复杂度将大大降低。由此我们考虑重新设计`find()`函数：**

```c++
int find(int x)
{
    if(x == fa[x])
        return x;
    else{
        fa[x] = find(fa[x]);  //父节点设为根节点
        return fa[x];         //返回父节点
    }
}
```

**可以简化成一行代码：**

```c
int find(int x)
{
    return x == fa[x] ? x : (fa[x] = find(fa[x]));
}
```

**我们把并查集算法封装成一个类：**

```c++
// union-find disjoint sets
class UnionFindSets {
private:
    vector<int> father;
public:
    explicit UnionFindSets(int n) : father(n + 1) {
        for (int i = 1; i <= n; i++) father[i] = i;
    }
    int find(int x) {
        return x == father[x] ? x : (father[x] = find(father[x]));
    }
    void merge(int i, int j) {
        father[find(i)] = find(j);
    }
};
```



**有了并查集的思想，我们已经可以解决一些不太容易的问题，比如：**[洛谷 P1551 亲戚](https://www.luogu.com.cn/problem/P1551)

```shell
# 输入样例
# 第一行分别表示n个人，m个亲戚关系，查询p对亲戚关系
# 后m行表示亲戚关系
# 后p行表示要查询的亲戚关系
6 5 3
1 2
1 5
3 4
5 2
1 3
1 4
2 3
5 6

# 输出
Yes
Yes
No
```

**这其实是一个很有现实意义的问题。我们可以建立模型，把所有人划分到若干个不相交的集合中，每个集合里的人彼此是亲戚。为了判断两个人是否为亲戚，只需看它们是否属于同一个集合即可。因此，这里就可以考虑用并查集进行维护了。基于我们上面已经实现的并查集类，我们可以很轻松的解决这个问题：**

```c++
int main() {
    int n, m, p;
    cin >> n >> m >> p;
    UnionFindSets uset(n);
    int a, b;
    for (int i = 0; i < m + p; i++) {
        cin >> a >> b;
        if (i < m) uset.merge(a, b);
        else {
            if (uset.find(a) == uset.find(b)) cout << "Yes";
            else cout << "No";
            if (i != m + p - 1) cout << endl;
        }
    }
    return 0;
}
```



### [拓扑排序](https://zhuanlan.zhihu.com/p/260112913)

**拓扑排序是对有向无环图（DAG）上的节点进行排序，使得对于每条有向边 $ u \rightarrow v$，$ u$ 都在 $ v$ 之前出现。简单的说，是在不破坏节点先后顺序的前提下，把DAG拉成一条链。**

<img src="https://pic2.zhimg.com/v2-ecb3af795e137fb78582689b9270d28d_1440w.jpg?source=172ae18b" alt="算法学习笔记(53): 拓扑排序" style="zoom: 20%;" />

**拓扑排序最经典的算法是`Kahn算法`。首先拿出所有入度为0的点排在前面，并在原图中将它们删除（如下左图），这时有些点的入度减少了，于是再拿出当前所有入度为0的点放在已经排序的序列后面，然后删除。因为是有向无环图，所以每时每刻都一定存在入度位0的点，直到所有点被删除：**

<div align="center">
	<img src="https://gitee.com/wzhdx/images/raw/master/202112151047304.jpg" alt="img" style="zoom:20%;" /><img src="https://pic1.zhimg.com/80/v2-13e4ae893d5c542b0f5ebb7d75bb09f8_1440w.jpg" alt="img" style="zoom:20%;" />
</div>
**给定`n`个点以及每条边，我们可以构建出点的拓扑排序：**

```c++
void topo_sort(unordered_map<int, vector<int>>& edges, vector<int>& in_deg, vector<int>& topo) {
    queue<int> q;
    for (int i = 0; i < in_deg.size(); i++) if (in_deg[i] == 0) q.push(i);
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        topo.push_back(t);
        for (int n : edges[t]) if (--degree[n] == 0) q.push(n);
    }
}
```



#### - 拓扑排序应用

[Leetcode 5947. 从给定原材料中找到所有可以做出的菜](https://leetcode-cn.com/problems/find-all-possible-recipes-from-given-supplies/)

**菜需要用原材料来做，菜本身也可能是一种原材料，返回所有可以做出来的菜**

```shell
输入：recipes = ["bread","sandwich","burger"], ingredients = [["yeast","flour"],["bread","meat"],["sandwich","meat","bread"]], supplies = ["yeast","flour","meat"]
输出：["bread","sandwich","burger"]
解释：
我们可以做出 "bread" ，因为我们有原材料 "yeast" 和 "flour" 。
我们可以做出 "sandwich" ，因为我们有原材料 "meat" 且可以做出原材料 "bread" 。
我们可以做出 "burger" ，因为我们有原材料 "meat" 且可以做出原材料 "bread" 和 "sandwich" 。
```

**这一题常规思路显然是：遍历所有菜，每道菜判断所需的材料是不是都有，如果都有则可以做出来，删掉这道菜并把这道菜放入原材料列表；循环结束条件为：所有菜都做出来了或者在一次迭代中没有任何菜可以做出来。这种做法的明显缺陷就是存在“套娃”情况，最差时间复杂度为 $ O(n^2)$**

**这道题实际上可以换一种思路考虑，即原材料（包括菜本身）可以做哪些菜，如下图所示：**

<img src="https://gitee.com/wzhdx/images/raw/master/202112282017858.png" alt="未命名绘图 (11)" style="zoom: 40%;" />

**这就形成了一张有向图，其中原材料的入度必为0，菜的入度肯定不为0，直观上我们就能发现这就是一个典型的拓扑排序问题。构建一个队列，我们先让所有的原材料入队，然后遍历队列，同时将元素指向的元素的入度-1，如果指向的元素入度变为了0，表示这道菜现在可以做出来了，让它入队。这个阶段所有入队的元素即为答案**



### 欧拉路径

**欧拉路径：一条能够不重不漏的经过图上每一条边的路径，即小学奥数中的“一笔画问题”。一个图有欧拉路径需要满足以下条件：**

- **这是一个连通图**
- **若是无向图，这个图的度数为奇数的点的个数必须是0或2；若是有向图，则要么所有点的入度和出度相等，要么有且只有两个点的入度分别比出度大1和小1**

**<font color=red>[5932. 合法重新排列数对（2021-12-05 周赛压轴）](https://leetcode-cn.com/problems/valid-arrangement-of-pairs/)</font>**

**注意：数据保证至少存在一个 `pairs` 的合法重新排列**

```shell
输入：pairs = [[5,1],[4,5],[11,9],[9,4]]
输出：[[11,9],[9,4],[4,5],[5,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3
```

**上面已经讨论过，对于有向连通图，如果存在欧拉路径，则要么所有点的入度和出度相等，要么有且只有两个点的入度分别比出度大1和小1。如果所有点的入度和出度相等，那么无论从图上哪一点出发，都必定能得到欧拉路径；如果存在入度出度不等的点，那么欧拉路径的起点必定是入度比出度小1的点（终点入度比出度大1）**

<img src="https://gitee.com/wzhdx/images/raw/master/202112051958394.png" alt="未命名绘图" style="zoom:40%;" />

**因此，算法的第一步是遍历所有边（即`pair`对），找出欧拉路径的起点（如果所有点的入度出度相等则可以任取一点）。然后由这一点向外作深度搜索。**

**<font color=aqua>注意：向外作深度搜索不总是成功的，但不成功的原因是唯一的：即路径提前到达了终点</font>**

<img src="https://gitee.com/wzhdx/images/raw/master/202112052020477.png" alt="未命名绘图 (1)" style="zoom:40%;" />

**因此，寻找欧拉路径的深度优先搜索与传统的深度优先搜索有差别，其表现在：先搜索，后入栈，结果逆序输出：**

```c++
vector<int>& e = mp[sn];
while (!e.empty()) {
    int fn = e.back();
    e.pop_back();
    dfs(fn);
    res.push_back(vector<int>{sn, fn});
}
```

```shell
# 已知起点为节点1，1的出度为2，如果先访问节点3，仍然可以得到正确结果
dfs(1) --> (1, 3) --> dfs(3) --> ( ) --> push(1, 3) --> (1, 2) --> dfs(2) --> (2, 1) --> dfs(1) --> ( ) --> push(2, 1) --> push(1, 2)
# (1, 3), (2, 1), (1, 2)
# reverse: (1, 2), (2, 1), (1, 3)

# 如果先访问节点2，同样是正确结果
dfs(1) --> (1, 2) --> dfs(2) --> (2, 1) --> dfs(1) --> (1, 3) --> ( ) --> push(1, 3) --> push(2, 1) --> push(1, 2)
```

```c++
class Solution {
public:
    map<int, vector<int>> mp;
    map<int, int> degree;
    vector<vector<int>> res;

    void dfs(int sn) {
        vector<int>& e = mp[sn];
        while (!e.empty()) {
            int fn = e.back();
            e.pop_back();
            dfs(fn);
            res.push_back(vector<int>{sn, fn});
        }
    }

    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        for (auto& p : pairs) {
            mp[p[0]].push_back(p[1]);
            degree[p[0]]--;
            degree[p[1]]++;
        }
        for (auto it = degree.begin(); it != degree.end(); it++) {
            if (it->second == -1) dfs(it->first);
        }
        if (res.empty()) dfs(degree.begin()->first);
        reverse(res.begin(), res.end());
        return res;
    }
};
```





---

## 周赛复盘



### 2022-03-13 第284场周赛（1143/8483）

**两个月没参加周赛，第一题做着急了，不测直接交错了一次；第三题题目一开始写错了，后面把有争议的句子改了，导致多错了一次**

**话说两个月没参加比赛人数怎么多了这么多。。。**







### 2022-01-09 第275场周赛（1856/4786）

**做得亚托洗。只做出来第一题**

[2. 最少交换次数来组合所有的 1 II【环形数组 滑动窗口】](https://leetcode-cn.com/problems/minimum-swaps-to-group-all-1s-together-ii/)

**把由`0`、`1`构成的环形数组中所有的`1`排到一起（环形数组指的是首尾元素被视作相邻）**

```shell
输入：nums = [0,1,1,1,0,0,1,1,0]
输出：2
解释：这里列出一些能够将所有 1 聚集在一起的方案：
[1,1,1,0,0,0,0,1,1] 交换 2 次（利用数组的环形特性）。
[1,1,1,1,1,0,0,0,0] 交换 2 次。
无法在交换 0 次或 1 次的情况下将数组中的所有 1 聚集在一起。
因此，需要的最少交换次数为 2 。
```

**明明是一道非常简单的题目，始终抓不住重点。<font color=red>涉及环形数组，可以考虑把数组复制一遍。</font>再结合滑动窗口的思想问题迎刃而解，也就是一道常规的第二题的难度。**

```c++
class Solution {
public:
    int minSwaps(vector<int>& nums) {
        int length = accumulate(nums.begin(), nums.end(), 0);
        nums.insert(nums.end(), nums.begin(), nums.end());
        int cur_val = 0, res = 0;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= length) cur_val -= nums[i-length];
            cur_val += nums[i];
            res = max(cur_val, res);
        }
        return length - res;
    }
};
```

[3. 统计追加字母可以获得的单词数【字符串哈希】](https://leetcode-cn.com/problems/count-words-obtained-after-adding-a-letter/)

```shell
输入：startWords = ["ant","act","tack"], targetWords = ["tack","act","acti"]
输出：2
解释：
- 为了形成 targetWords[0] = "tack" ，可以选用 startWords[1] = "act" ，追加字母 'k' ，并重排 "actk" 为 "tack" 。
- startWords 中不存在可以用于获得 targetWords[1] = "act" 的字符串。
  注意 "act" 确实存在于 startWords ，但是 必须 在重排前给这个字符串追加一个字母。
- 为了形成 targetWords[2] = "acti" ，可以选用 startWords[1] = "act" ，追加字母 'i' ，并重排 "acti" 为 "acti" 自身。
```

**题意不是很明确，最关键的信息：“单词中不允许出现重复字符”，给的太隐晦了。**

**在掌握上面的条件后，我们可以把所有字符串都构造成26位二进制表示的整数（`int`类型就可以），字符串转化成的整数相等则字符串相等。我们建立哈希表存储所有可能通过`startWords`转化得到的字符串，然后遍历`targetWords`中的字符串看是否在哈希表中**

[4. 全部开花的最早一天](https://leetcode-cn.com/problems/earliest-possible-day-of-full-bloom/)

**这道题对直觉的要求比较高，没有特别的难点，但是没找到规律可能很困难**







### 2021-12-28 第68场周赛（虚拟）

**做的不太好，第二题暴力能过但对<font color=red>遍历数组删除元素的操作不熟练，导致复杂度还是高了</font>。同时要注意在C++中操作二维数组一定要注意浅拷贝的问题，非常危险的错误一定要避免**

[2. 从给定原材料中找到所有可以做出的菜【拓扑排序】](#- 拓扑排序应用)



### 2021-12-26 第273场周赛（684/4367）

**第三题失误多WA了一次，难受，其它的还可以，基本是正常水平。这次的最后一题，看了一眼题解发现居然暴力做就可以了，震惊，然后下午试了一下居然真给过了，难受了。做最后一题心里还是有一种畏惧感，但如果暴力给过的话，其实今天这个题目是真不难**

[4. 还原原数组](https://leetcode-cn.com/problems/recover-the-original-array/)

```shell
输入：nums = [2,10,6,4,8,12]
输出：[3,7,11]
解释：
如果 arr = [3,7,11] 且 k = 1 ，那么 lower = [2,6,10] 且 higher = [4,8,12] 。
组合 lower 和 higher 得到 [2,6,10,4,8,12] ，这是 nums 的一个排列。
另一个有效的数组是 arr = [5,7,9] 且 k = 3 。在这种情况下，lower = [2,4,6] 且 higher = [8,10,12] 。
```

```c++
class Solution {
public:
    vector<int> recoverArray(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        vector<int> res;
        for (int i = 1; i < nums.size(); i++) {
            int gap = nums[i] - nums[0];
            if (gap % 2 || gap == 0) continue;
            gap /= 2;
            res.clear();
            queue<int> q;
            q.push(nums[0]);
            for (int j = 1; j < nums.size(); j++) {
                if (q.empty() || q.front() + gap * 2 > nums[j]) q.push(nums[j]);
                else if (nums[j] > q.front() + 2 * gap) break;
                else {
                    res.push_back(q.front() + gap);
                    q.pop();
                }
            }
            if (res.size() == nums.size() / 2) break;
        }
        return res;
    }
};
```



### 2021-12-19 第272场周赛（1451 / 4697）

**这个礼拜做的不好，一方面简单的题目没有一遍过，另一方面相对容易的压轴没做出**

**<font color=aqua>用C++做题时一定要注意一个问题：在做乘法的时候要考虑数字是否会越界（实际上大概率是会的），所以得确保你取的数据类型是合理的，简单的题目一定不能在这个地方出问题</font>**

[4. 使数组 K 递增的最少操作次数](https://leetcode-cn.com/problems/minimum-operations-to-make-the-array-k-increasing/)

**解题参考[最长递增子序列问题](#最长递增子序列（LIS）问题)**



### 2021-12-12 第271场周赛（831 / 4561）

**这个礼拜的周赛总体做的还是有进步的，上个礼拜对一些知识点进行了整理，对基础内容的掌握要熟悉了一点，体现在周赛上，就是写出来的算法变简洁了，开始利用C++的数据结构解决问题。**

[4. 摘水果（leetcode 955）](https://leetcode-cn.com/problems/maximum-fruits-harvested-after-at-most-k-steps/)

**这一题做的时候思路错了，走进了死胡同完全没想着出来。直到结束以后猛然意识到前缀和+二分明显要更快一点。不过知道了正确思路到最后敲出来还是花了太多时间，类似的题目还是要多做**

```c++
class Solution {
public:
    // return index where target should be inserted.
    int binary_insert(const vector<int>& nums, int target) {
        int left = 0, right = nums.size(), mid;
        while (left < right) {
            mid = (left + right) / 2;
            if (nums[mid] < target) left = mid + 1;
            else right = mid;
        }
        return left;
    }

    int maxTotalFruits(vector<vector<int>>& fruits, int startPos, int k) {
        vector<int> pre_sum, position;
        int cur_val = 0, res = 0;
        for (auto & fruit : fruits) {
            pre_sum.push_back(cur_val += fruit[1]);
            position.push_back(fruit[0]);
        }
        int start_idx = binary_insert(position, startPos);
        for (int i = start_idx - 1; i >= 0 and k >= startPos - position[i]; i--) {
            int tmp_k = k - 2 * (startPos - position[i]);
            if (tmp_k >= 0) {
                int last_idx = binary_insert(position, startPos + tmp_k + 1);
                if (i == 0) res = max(res, pre_sum[last_idx-1]);
                else res = max(res, pre_sum[last_idx-1] - pre_sum[i-1]);
            } else {
                if (i == 0) res = max(res, pre_sum[start_idx-1]);
                else res = max(res, pre_sum[start_idx-1] - pre_sum[i-1]);
            }
        }

        for (int i = start_idx; i < fruits.size() and k >= position[i] - startPos; i++) {
            int tmp_k = k - 2 * (position[i] - startPos);
            if (tmp_k >= 0) {
                int first_idx = binary_insert(position, startPos - tmp_k);
                if (first_idx == 0) res = max(res, pre_sum[i]);
                else res = max(res, pre_sum[i] - pre_sum[first_idx - 1]);
            } else {
                if (start_idx == 0) res = max(res, pre_sum[i]);
                else res = max(res, pre_sum[i] - pre_sum[start_idx - 1]);
            }
        }
        return res;
    }
};
```





### 2021-12-05 第270场周赛（1845 / 4747）

**<font color=red>3. 从二叉树一个节点到另一个节点每一步的方向</font>**

**示例：**

![img](https://assets.leetcode.com/uploads/2021/11/15/eg1.png)**

```shell
输入：root = [5,1,2,3,null,6,4], startValue = 3, destValue = 6
输出："UURL"
解释：最短路径为：3 → 1 → 5 → 2 → 6 。
```

**这题做的时候钻到死胡同了。完全没有必要从中序遍历的角度入手，这一题直接通过dfs记忆化搜索两个节点就可以，每个节点会对应一个记忆结果，在上面的示例中就是`start = 'LL'`，`dest = 'RL`；然后依次比照两个字符串的每个字符，相同说明是来自同一个节点的。从第一个不同的节点开始，`start`每个额外的字符就是要向上走的一步，`dest`就是从共同节点再往下走的每一步。在这题中从一开始就不相同了，这意味着`start`要走到根节点再往另一边走，所以会有`len(start)`数量的`U`，从两个字符串不相同的下标开始就是分叉的地方，因此`dest`后面的字符串就是要走的剩余路线**

```c++
class Solution {
public:
    string path, paths, pathd;
    int s, d;
    void dfs(TreeNode* node) {
        if (node->val == s) paths = path;
        if (node->val == d) pathd = path;
        if (node->left) {
            path.push_back('L');
            dfs(node->left);
            path.pop_back();
        }
        if (node->right) {
            path.push_back('R');
            dfs(node->right);
            path.pop_back();
        }
    }

    string getDirections(TreeNode* root, int startValue, int destValue) {
        this->s = startValue, this->d = destValue;
        dfs(root);
        int i = 0;
        while (paths[i] == pathd[i]) i++;
        return string(paths.size() - i, 'U') + pathd.substr(i);
    }
};
```

**<font color=red>4. 合法重新排列数对</font>**

[**见连通图问题-欧拉路径**](#欧拉路径)



### 2021-11-21 第268场周赛

[1. 两栋颜色不同且距离最远的房子](https://leetcode-cn.com/problems/two-furthest-houses-with-different-colors/)

![img](https://assets.leetcode.com/uploads/2021/10/31/eg1.png)

```shell
输入：colors = [1,1,1,6,1,1,1]
输出：3
解释：上图中，颜色 1 标识成蓝色，颜色 6 标识成红色。
两栋颜色不同且距离最远的房子是房子 0 和房子 3 。
房子 0 的颜色是颜色 1 ，房子 3 的颜色是颜色 6 。两栋房子之间的距离是 abs(0 - 3) = 3 。
注意，房子 3 和房子 6 也可以产生最佳答案。
```

**这一题，暴力解时间复杂度为 $ O(n^2)$，在第一题中一般也是能过的（事实上也确实没问题）。但就是很膈应，毕竟还是有超时风险。当时做的时候想了很久其他解法但实在没想出更优策略，最后还是暴力交了**

**这一题实际上注意到：<font color=aqua>距离最远的两个房子中至少有一个是在边界（最左或最右）。</font>**

**如果能注意到上面的条件，那么所有问题迎刃而解。我们只需要从左到右扫一次找与最右侧不同的房子；再从右到左扫一次找与最左侧不同的房子，最后取二者中的最大值即可**

```c++
class Solution {
public:
    int maxDistance(vector<int>& colors) {
        int left = 0, right = colors.size() - 1, n = colors.size() - 1;
        while (colors[n] == colors[left]) left++;
        while (colors[0] == colors[right]) right--;
        return max(right, n - left);
    }
};
```



[3. 区间内查询数字的频率【哈希+二分】](https://leetcode-cn.com/problems/range-frequency-queries/)

**一个数组类，一个查询函数`query(int left, int right, int value)`，用来查范围内的`value`出现了多少次**

```shell
输入：
["RangeFreqQuery", "query", "query"]
[[[12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]], [1, 2, 4], [0, 11, 33]]
输出：
[null, 1, 2]

解释：
RangeFreqQuery rangeFreqQuery = new RangeFreqQuery([12, 33, 4, 56, 22, 2, 34, 33, 22, 12, 34, 56]);
rangeFreqQuery.query(1, 2, 4); // 返回 1 。4 在子数组 [33, 4] 中出现 1 次。
rangeFreqQuery.query(0, 11, 33); // 返回 2 。33 在整个子数组中出现 2 次。
```

**这一题，如果没有任何其它操作的话，`query()`的复杂度肯定是 $ O(n)$，但这个复杂度是超时的，因此要考虑降低复杂度。**

**我先考虑构造一个map数组，每个map存储当前下标及之前的所有数字出现的次数，然后在`query()`的时候只需要作一次减法就可以，时间复杂度 $ O(1)$，但仍然超时，应该是在构造map的过程中超时了**

**实际上我们只需要用一个map存储每个value出现的下标就可以了。在`query()`的时候，我们可以拿到当前value在数组中出现的下标，然后通过二分得到结果（因为下标数组必然是有序的）。**

**这里实际上有一个细节要注意，就是二分是用`upper_bound()`还是`lower_bound()`呢？因为两侧都是闭区间，所以理论上两个二分采用的策略应该是不同的（因为是后面的减去前面的），<font color=aqua>注意`upper_bound()`是得到比value大的第一个下标（>），而`lower_bound()`是得到不大于value的第一个下标（>=）</font>**

```c++
class RangeFreqQuery {
public:
    unordered_map<int, vector<int>> umap;
    RangeFreqQuery(vector<int>& arr) {
        unordered_map<int, vector<int>> mp;
        for (int i = 0; i < arr.size(); i++) {
            mp[arr[i]].push_back(i);
        }
        umap = mp;
    }
    int query(int left, int right, int value) {
        vector<int>& idx_list = umap[value];
        return upper_bound(idx_list.begin(), idx_list.end(), right) -
        upper_bound(idx_list.begin(), idx_list.end(), left-1);
    }
};
```



[4. k 镜像数字的和【回文数字+打表】](https://leetcode-cn.com/problems/sum-of-k-mirror-numbers/)

一个 **k 镜像数字** 指的是一个在十进制和 k 进制下从前往后读和从后往前读都一样的 **没有前导 0** 的 **正** 整数。

- `2 <= k <= 9`
- `1 <= n <= 30`

```shell
输入：k = 3, n = 7
输出：499
解释：
7 个最小的 3 镜像数字和它们的三进制表示如下：
  十进制       三进制
    1          1
    2          2
    4          11
    8          22
    121        11111
    151        12121
    212        21212
它们的和为 1 + 2 + 4 + 8 + 121 + 151 + 212 = 499 。
```

**这一题，暴力的思路非常清晰，遍历整数然后判断其十进制和k进制是否为回文即可，但显然超时**

**为了进行优化，我们考虑是否可以按顺序依次计算十进制中的回文串，然后只判断在k进制它是否也是回文。但这种逻辑仍然超时。**

**但我们注意到：本题的变量范围很小，因此尽管方法超时，但我们可以离线算出结果然后直接打表提交**

```c++
class Solution {
public:
    vector<vector<long long>> vec = {
            {1, 3, 5, 7, 9, 33, 99, 313, 585, 717, 7447, 9009, 15351, 32223, 39993, 53235, 53835, 73737, 585585, 1758571, 1934391, 1979791, 3129213, 5071705, 5259525, 5841485, 13500531, 719848917, 910373019, 939474939},
            {1, 2, 4, 8, 121, 151, 212, 242, 484, 656, 757, 29092, 48884, 74647, 75457, 76267, 92929, 93739, 848848, 1521251, 2985892, 4022204, 4219124, 4251524, 4287824, 5737375, 7875787, 7949497, 27711772, 83155138},
            {1, 2, 3, 5, 55, 373, 393, 666, 787, 939, 7997, 53235, 55255, 55655, 57675, 506605, 1801081, 2215122, 3826283, 3866683, 5051505, 5226225, 5259525, 5297925, 5614165, 5679765, 53822835, 623010326, 954656459, 51717171715},
            {1, 2, 3, 4, 6, 88, 252, 282, 626, 676, 1221, 15751, 18881, 10088001, 10400401, 27711772, 30322303, 47633674, 65977956, 808656808, 831333138, 831868138, 836131638, 836181638, 2512882152, 2596886952, 2893553982, 6761551676, 12114741121, 12185058121},
            {1, 2, 3, 4, 5, 7, 55, 111, 141, 191, 343, 434, 777, 868, 1441, 7667, 7777, 22022, 39893, 74647, 168861, 808808, 909909, 1867681, 3097903, 4232324, 4265624, 4298924, 4516154, 4565654},
            {1, 2, 3, 4, 5, 6, 8, 121, 171, 242, 292, 16561, 65656, 2137312, 4602064, 6597956, 6958596, 9470749, 61255216, 230474032, 466828664, 485494584, 638828836, 657494756, 858474858, 25699499652, 40130703104, 45862226854, 61454945416, 64454545446},
            {1, 2, 3, 4, 5, 6, 7, 9, 121, 292, 333, 373, 414, 585, 3663, 8778, 13131, 13331, 26462, 26662, 30103, 30303, 207702, 628826, 660066, 1496941, 1935391, 1970791, 4198914, 55366355},
            {1, 2, 3, 4, 5, 6, 7, 8, 191, 282, 373, 464, 555, 646, 656, 6886, 25752, 27472, 42324, 50605, 626626, 1540451, 1713171, 1721271, 1828281, 1877781, 1885881, 2401042, 2434342, 2442442},
    };
    long long kMirror(int k, int n) {
        long long res = 0;
        for (int i = 0; i < n; i++) {
            res += vec[k-2][i];
        }
        return res;
    }
};
```

 



### 2021-11-13 第65场双周赛

[4. 你可以安排的最多任务数目【二分+双端队列】](https://leetcode-cn.com/problems/maximum-number-of-tasks-you-can-assign/)

```shell
输入：tasks = [10,15,30], workers = [0,10,10,10,10], pills = 3, strength = 10
输出：2
解释：
我们可以按照如下方案安排药丸：
- 给 0 号和 1 号工人药丸。
- 0 号工人完成任务 0（0 + 10 >= 10）
- 1 号工人完成任务 1（10 + 10 >= 15）
```

- **问题的关键在于：<font color=aqua>如果完成了m个任务，那么一定是最小的m个任务被最大的m个workers完成了。</font>**
- **如果能在 $ O(n)$ 的时间内判断出m个任务是否可以被m个人完成，那么结合二分，整体的时间复杂度就是 $ O(nlogn)$**
- **判断m个任务是否可以被m个人完成的过程**
    - **构建一个双端队列用来保存能力范围内的任务**
    - **我们可以从小到大遍历人**
    - **每次遍历，先让能完成的任务入队**
    - **然后，如果队为空或者队首元素大于人物能力，则需要嗑药**
        - **如果没有药了直接返回false**
        - **如果有药，让磕药后能完成的任务入队。如果队还为空，则返回false。若不为空，让队尾元素出队（让尽可能大的出队）**
    - **如果队非空且队首元素小于人物能力，则直接让队首元素出队（反正当前的人物是最小的，就让他完成最简单的任务就好）**

```c++
class Solution {
public:
    bool check_valid(vector<int>& t, vector<int>& w, int p, int val) {
        deque<int> deq;
        int idx = 0;
        for (int i = w.size() - 1; i >= 0; i--) {
            while (idx < t.size() && t[idx] <= w[i]) deq.push_back(t[idx++]);
            if (deq.empty() or deq.front() > w[i]) {
                if (p == 0) return false;
                p--;
                int cur_val = val + w[i];
                while (idx < t.size() && t[idx] <= cur_val) deq.push_back(t[idx++]);
                if (deq.empty()) return false;
                deq.pop_back();
            } else deq.pop_front();
        }
        return true;
    }

    int maxTaskAssign(vector<int>& tasks, vector<int>& workers, int pills, int strength) {
        sort(tasks.begin(), tasks.end());
        sort(workers.begin(), workers.end(), [](const int& a, const int& b) { return a > b; });
        int t_size = tasks.size(), left = 0, right = min(int(workers.size()), t_size), mid;
        while (left < right) {
            mid = (left + right) / 2;
            vector<int> sub_tasks(tasks.begin(), tasks.begin() + mid + 1), sub_work(workers.begin(), workers.begin() + mid + 1);
            if (check_valid(sub_tasks, sub_work, pills, strength)) left = max(left+1, mid);
            else right = mid;
        }
        return left;
    }
};
```

​	**	
